


/* Generated by glib-mkenums. Do not edit */

#include "nm-enum-types.h"

#include "nm-config.h" 
#include "nm-config-device.h" 
#include "nm-device.h" 
#include "nm-device-bond.h" 
#include "nm-device-bridge.h" 
#include "nm-device-ethernet.h" 
#include "nm-device-factory.h" 
#include "nm-device-generic.h" 
#include "nm-device-gre.h" 
#include "nm-device-infiniband.h" 
#include "nm-device-macvlan.h" 
#include "nm-device-private.h" 
#include "nm-device-team.h" 
#include "nm-device-tun.h" 
#include "nm-device-veth.h" 
#include "nm-device-vlan.h" 
#include "nm-device-vxlan.h" 
#include "nm-dhcp-client.h" 
#include "nm-dhcp-dhclient.h" 
#include "nm-dhcp-dhclient-utils.h" 
#include "nm-dhcp-dhcpcd.h" 
#include "nm-dhcp-manager.h" 
#include "nm-dns-dnsmasq.h" 
#include "nm-dns-unbound.h" 
#include "nm-dns-manager.h" 
#include "nm-dns-plugin.h" 
#include "nm-dns-utils.h" 
#include "nm-dnsmasq-manager.h" 
#include "nm-dnsmasq-utils.h" 
#include "nm-firewall-manager.h" 
#include "nm-logging.h" 
#include "nm-fake-platform.h" 
#include "nm-linux-platform.h" 
#include "nm-platform.h" 
#include "wifi-utils-nl80211.h" 
#include "wifi-utils-private.h" 
#include "wifi-utils.h" 
#include "nm-fake-rdisc.h" 
#include "nm-lndp-rdisc.h" 
#include "nm-rdisc.h" 
#include "nm-posix-signals.h" 
#include "nm-ppp-manager.h" 
#include "nm-ppp-status.h" 
#include "nm-agent-manager.h" 
#include "nm-inotify-helper.h" 
#include "nm-secret-agent.h" 
#include "nm-settings-connection.h" 
#include "nm-settings-error.h" 
#include "nm-settings-utils.h" 
#include "nm-settings.h" 
#include "nm-system-config-interface.h" 
#include "common.h" 
#include "nm-keyfile-connection.h" 
#include "plugin.h" 
#include "reader.h" 
#include "utils.h" 
#include "writer.h" 
#include "nm-supplicant-config.h" 
#include "nm-supplicant-interface.h" 
#include "nm-supplicant-manager.h" 
#include "nm-supplicant-settings-verify.h" 
#include "nm-supplicant-types.h" 
#include "nm-call-store.h" 
#include "nm-vpn-connection.h" 
#include "nm-vpn-manager.h" 
#include "nm-vpn-service.h" 
#include "nm-activation-request.h" 
#include "nm-active-connection.h" 
#include "nm-connection-provider.h" 
#include "nm-connectivity.h" 
#include "nm-dbus-manager.h" 
#include "nm-dcb.h" 
#include "nm-dhcp4-config.h" 
#include "nm-dhcp6-config.h" 
#include "nm-dispatcher.h" 
#include "nm-ip4-config.h" 
#include "nm-ip6-config.h" 
#include "nm-manager-auth.h" 
#include "nm-auth-subject.h" 
#include "nm-manager.h" 
#include "nm-policy.h" 
#include "nm-properties-changed-signal.h" 
#include "nm-rfkill-manager.h" 
#include "nm-session-monitor.h" 
#include "nm-session-utils.h" 
#include "nm-sleep-monitor.h" 
#include "nm-types.h" 
#include "NetworkManagerUtils.h" 
#include "wifi-utils-wext.h" 
#include "nm-device-wimax.h"

GType
nm_device_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_ERROR_CONNECTION_ACTIVATING, "NM_DEVICE_ERROR_CONNECTION_ACTIVATING", "ConnectionActivating" },
        { NM_DEVICE_ERROR_CONNECTION_INVALID, "NM_DEVICE_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_DEVICE_ERROR_NOT_ACTIVE, "NM_DEVICE_ERROR_NOT_ACTIVE", "NotActive" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_unmanaged_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_UNMANAGED_NONE, "NM_UNMANAGED_NONE", "nm-unmanaged-none" },
        { NM_UNMANAGED_DEFAULT, "NM_UNMANAGED_DEFAULT", "nm-unmanaged-default" },
        { NM_UNMANAGED_INTERNAL, "NM_UNMANAGED_INTERNAL", "nm-unmanaged-internal" },
        { NM_UNMANAGED_USER, "NM_UNMANAGED_USER", "nm-unmanaged-user" },
        { __NM_UNMANAGED_LAST, "__NM_UNMANAGED_LAST", "--nm-unmanaged-last" },
        { NM_UNMANAGED_LAST, "NM_UNMANAGED_LAST", "nm-unmanaged-last" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMUnmanagedFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_bond_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_BOND_ERROR_CONNECTION_NOT_BOND, "NM_BOND_ERROR_CONNECTION_NOT_BOND", "ConnectionNotBond" },
        { NM_BOND_ERROR_CONNECTION_INVALID, "NM_BOND_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_BOND_ERROR_CONNECTION_INCOMPATIBLE, "NM_BOND_ERROR_CONNECTION_INCOMPATIBLE", "ConnectionIncompatible" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMBondError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_bridge_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_BRIDGE_ERROR_CONNECTION_NOT_BRIDGE, "NM_BRIDGE_ERROR_CONNECTION_NOT_BRIDGE", "ConnectionNotBridge" },
        { NM_BRIDGE_ERROR_CONNECTION_INVALID, "NM_BRIDGE_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_BRIDGE_ERROR_CONNECTION_INCOMPATIBLE, "NM_BRIDGE_ERROR_CONNECTION_INCOMPATIBLE", "ConnectionIncompatible" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMBridgeError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_ethernet_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_ETHERNET_ERROR_CONNECTION_NOT_WIRED, "NM_ETHERNET_ERROR_CONNECTION_NOT_WIRED", "ConnectionNotWired" },
        { NM_ETHERNET_ERROR_CONNECTION_INVALID, "NM_ETHERNET_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_ETHERNET_ERROR_CONNECTION_INCOMPATIBLE, "NM_ETHERNET_ERROR_CONNECTION_INCOMPATIBLE", "ConnectionIncompatible" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMEthernetError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_generic_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_GENERIC_ERROR_CONNECTION_NOT_GENERIC, "NM_DEVICE_GENERIC_ERROR_CONNECTION_NOT_GENERIC", "ConnectionNotGeneric" },
        { NM_DEVICE_GENERIC_ERROR_CONNECTION_INVALID, "NM_DEVICE_GENERIC_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_DEVICE_GENERIC_ERROR_CONNECTION_INCOMPATIBLE, "NM_DEVICE_GENERIC_ERROR_CONNECTION_INCOMPATIBLE", "ConnectionIncompatible" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceGenericError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_infiniband_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_INFINIBAND_ERROR_CONNECTION_NOT_INFINIBAND, "NM_INFINIBAND_ERROR_CONNECTION_NOT_INFINIBAND", "ConnectionNotInfiniband" },
        { NM_INFINIBAND_ERROR_CONNECTION_INVALID, "NM_INFINIBAND_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_INFINIBAND_ERROR_CONNECTION_INCOMPATIBLE, "NM_INFINIBAND_ERROR_CONNECTION_INCOMPATIBLE", "ConnectionIncompatible" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMInfinibandError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_team_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_TEAM_ERROR_CONNECTION_NOT_TEAM, "NM_TEAM_ERROR_CONNECTION_NOT_TEAM", "ConnectionNotTeam" },
        { NM_TEAM_ERROR_CONNECTION_INVALID, "NM_TEAM_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_TEAM_ERROR_CONNECTION_INCOMPATIBLE, "NM_TEAM_ERROR_CONNECTION_INCOMPATIBLE", "ConnectionIncompatible" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMTeamError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vlan_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VLAN_ERROR_CONNECTION_NOT_VLAN, "NM_VLAN_ERROR_CONNECTION_NOT_VLAN", "ConnectionNotVlan" },
        { NM_VLAN_ERROR_CONNECTION_INVALID, "NM_VLAN_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_VLAN_ERROR_CONNECTION_INCOMPATIBLE, "NM_VLAN_ERROR_CONNECTION_INCOMPATIBLE", "ConnectionIncompatible" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVlanError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_dhcp_state_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { DHC_NBI, "DHC_NBI", "nbi" },
        { DHC_PREINIT, "DHC_PREINIT", "preinit" },
        { DHC_PREINIT6, "DHC_PREINIT6", "preinit6" },
        { DHC_BOUND4, "DHC_BOUND4", "bound4" },
        { DHC_BOUND6, "DHC_BOUND6", "bound6" },
        { DHC_IPV4LL, "DHC_IPV4LL", "ipv4ll" },
        { DHC_RENEW4, "DHC_RENEW4", "renew4" },
        { DHC_RENEW6, "DHC_RENEW6", "renew6" },
        { DHC_REBOOT, "DHC_REBOOT", "reboot" },
        { DHC_REBIND4, "DHC_REBIND4", "rebind4" },
        { DHC_REBIND6, "DHC_REBIND6", "rebind6" },
        { DHC_DEPREF6, "DHC_DEPREF6", "depref6" },
        { DHC_STOP, "DHC_STOP", "stop" },
        { DHC_STOP6, "DHC_STOP6", "stop6" },
        { DHC_MEDIUM, "DHC_MEDIUM", "medium" },
        { DHC_TIMEOUT, "DHC_TIMEOUT", "timeout" },
        { DHC_FAIL, "DHC_FAIL", "fail" },
        { DHC_EXPIRE, "DHC_EXPIRE", "expire" },
        { DHC_EXPIRE6, "DHC_EXPIRE6", "expire6" },
        { DHC_RELEASE, "DHC_RELEASE", "release" },
        { DHC_RELEASE6, "DHC_RELEASE6", "release6" },
        { DHC_START, "DHC_START", "start" },
        { DHC_ABEND, "DHC_ABEND", "abend" },
        { DHC_END, "DHC_END", "end" },
        { DHC_END_OPTIONS, "DHC_END_OPTIONS", "end-options" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDHCPState"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_dhcp_manager_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DHCP_MANAGER_ERROR_BAD_CLIENT, "NM_DHCP_MANAGER_ERROR_BAD_CLIENT", "BadClient" },
        { NM_DHCP_MANAGER_ERROR_INTERNAL, "NM_DHCP_MANAGER_ERROR_INTERNAL", "InternalError" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDHCPManagerError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_dns_manager_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DNS_MANAGER_ERROR_SYSTEM, "NM_DNS_MANAGER_ERROR_SYSTEM", "system" },
        { NM_DNS_MANAGER_ERROR_INVALID_NAMESERVER, "NM_DNS_MANAGER_ERROR_INVALID_NAMESERVER", "invalid-nameserver" },
        { NM_DNS_MANAGER_ERROR_INVALID_HOST, "NM_DNS_MANAGER_ERROR_INVALID_HOST", "invalid-host" },
        { NM_DNS_MANAGER_ERROR_INVALID_ID, "NM_DNS_MANAGER_ERROR_INVALID_ID", "invalid-id" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDnsManagerError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_dns_ip_config_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DNS_IP_CONFIG_TYPE_DEFAULT, "NM_DNS_IP_CONFIG_TYPE_DEFAULT", "default" },
        { NM_DNS_IP_CONFIG_TYPE_BEST_DEVICE, "NM_DNS_IP_CONFIG_TYPE_BEST_DEVICE", "best-device" },
        { NM_DNS_IP_CONFIG_TYPE_VPN, "NM_DNS_IP_CONFIG_TYPE_VPN", "vpn" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDnsIPConfigType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_dns_manager_resolv_conf_mode_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DNS_MANAGER_RESOLV_CONF_UNMANAGED, "NM_DNS_MANAGER_RESOLV_CONF_UNMANAGED", "unmanaged" },
        { NM_DNS_MANAGER_RESOLV_CONF_EXPLICIT, "NM_DNS_MANAGER_RESOLV_CONF_EXPLICIT", "explicit" },
        { NM_DNS_MANAGER_RESOLV_CONF_PROXY, "NM_DNS_MANAGER_RESOLV_CONF_PROXY", "proxy" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDnsManagerResolvConfMode"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_dns_masq_status_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DNSMASQ_STATUS_UNKNOWN, "NM_DNSMASQ_STATUS_UNKNOWN", "unknown" },
        { NM_DNSMASQ_STATUS_DEAD, "NM_DNSMASQ_STATUS_DEAD", "dead" },
        { NM_DNSMASQ_STATUS_RUNNING, "NM_DNSMASQ_STATUS_RUNNING", "running" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDnsMasqStatus"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_logging_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_LOGGING_ERROR_UNKNOWN_LEVEL, "NM_LOGGING_ERROR_UNKNOWN_LEVEL", "UnknownLevel" },
        { NM_LOGGING_ERROR_UNKNOWN_DOMAIN, "NM_LOGGING_ERROR_UNKNOWN_DOMAIN", "UnknownDomain" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMLoggingError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_platform_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_PLATFORM_ERROR_NONE, "NM_PLATFORM_ERROR_NONE", "none" },
        { NM_PLATFORM_ERROR_NOT_FOUND, "NM_PLATFORM_ERROR_NOT_FOUND", "not-found" },
        { NM_PLATFORM_ERROR_EXISTS, "NM_PLATFORM_ERROR_EXISTS", "exists" },
        { NM_PLATFORM_ERROR_WRONG_TYPE, "NM_PLATFORM_ERROR_WRONG_TYPE", "wrong-type" },
        { NM_PLATFORM_ERROR_NOT_SLAVE, "NM_PLATFORM_ERROR_NOT_SLAVE", "not-slave" },
        { NM_PLATFORM_ERROR_NO_FIRMWARE, "NM_PLATFORM_ERROR_NO_FIRMWARE", "no-firmware" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMPlatformError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_platform_reason_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_PLATFORM_REASON_NONE, "NM_PLATFORM_REASON_NONE", "none" },
        { NM_PLATFORM_REASON_INTERNAL, "NM_PLATFORM_REASON_INTERNAL", "internal" },
        { NM_PLATFORM_REASON_EXTERNAL, "NM_PLATFORM_REASON_EXTERNAL", "external" },
        { NM_PLATFORM_REASON_CACHE_CHECK, "NM_PLATFORM_REASON_CACHE_CHECK", "cache-check" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMPlatformReason"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_link_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_LINK_TYPE_NONE, "NM_LINK_TYPE_NONE", "none" },
        { NM_LINK_TYPE_UNKNOWN, "NM_LINK_TYPE_UNKNOWN", "unknown" },
        { NM_LINK_TYPE_ETHERNET, "NM_LINK_TYPE_ETHERNET", "ethernet" },
        { NM_LINK_TYPE_INFINIBAND, "NM_LINK_TYPE_INFINIBAND", "infiniband" },
        { NM_LINK_TYPE_OLPC_MESH, "NM_LINK_TYPE_OLPC_MESH", "olpc-mesh" },
        { NM_LINK_TYPE_WIFI, "NM_LINK_TYPE_WIFI", "wifi" },
        { NM_LINK_TYPE_WWAN_ETHERNET, "NM_LINK_TYPE_WWAN_ETHERNET", "wwan-ethernet" },
        { NM_LINK_TYPE_WIMAX, "NM_LINK_TYPE_WIMAX", "wimax" },
        { NM_LINK_TYPE_DUMMY, "NM_LINK_TYPE_DUMMY", "dummy" },
        { NM_LINK_TYPE_GRE, "NM_LINK_TYPE_GRE", "gre" },
        { NM_LINK_TYPE_GRETAP, "NM_LINK_TYPE_GRETAP", "gretap" },
        { NM_LINK_TYPE_IFB, "NM_LINK_TYPE_IFB", "ifb" },
        { NM_LINK_TYPE_LOOPBACK, "NM_LINK_TYPE_LOOPBACK", "loopback" },
        { NM_LINK_TYPE_MACVLAN, "NM_LINK_TYPE_MACVLAN", "macvlan" },
        { NM_LINK_TYPE_MACVTAP, "NM_LINK_TYPE_MACVTAP", "macvtap" },
        { NM_LINK_TYPE_OPENVSWITCH, "NM_LINK_TYPE_OPENVSWITCH", "openvswitch" },
        { NM_LINK_TYPE_TAP, "NM_LINK_TYPE_TAP", "tap" },
        { NM_LINK_TYPE_TUN, "NM_LINK_TYPE_TUN", "tun" },
        { NM_LINK_TYPE_VETH, "NM_LINK_TYPE_VETH", "veth" },
        { NM_LINK_TYPE_VLAN, "NM_LINK_TYPE_VLAN", "vlan" },
        { NM_LINK_TYPE_VXLAN, "NM_LINK_TYPE_VXLAN", "vxlan" },
        { NM_LINK_TYPE_BRIDGE, "NM_LINK_TYPE_BRIDGE", "bridge" },
        { NM_LINK_TYPE_BOND, "NM_LINK_TYPE_BOND", "bond" },
        { NM_LINK_TYPE_TEAM, "NM_LINK_TYPE_TEAM", "team" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMLinkType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_platform_signal_change_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_PLATFORM_SIGNAL_ADDED, "NM_PLATFORM_SIGNAL_ADDED", "added" },
        { NM_PLATFORM_SIGNAL_CHANGED, "NM_PLATFORM_SIGNAL_CHANGED", "changed" },
        { NM_PLATFORM_SIGNAL_REMOVED, "NM_PLATFORM_SIGNAL_REMOVED", "removed" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMPlatformSignalChangeType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_platform_source_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_PLATFORM_SOURCE_UNKNOWN, "NM_PLATFORM_SOURCE_UNKNOWN", "unknown" },
        { NM_PLATFORM_SOURCE_KERNEL, "NM_PLATFORM_SOURCE_KERNEL", "kernel" },
        { NM_PLATFORM_SOURCE_SHARED, "NM_PLATFORM_SOURCE_SHARED", "shared" },
        { NM_PLATFORM_SOURCE_IP4LL, "NM_PLATFORM_SOURCE_IP4LL", "ip4ll" },
        { NM_PLATFORM_SOURCE_PPP, "NM_PLATFORM_SOURCE_PPP", "ppp" },
        { NM_PLATFORM_SOURCE_WWAN, "NM_PLATFORM_SOURCE_WWAN", "wwan" },
        { NM_PLATFORM_SOURCE_VPN, "NM_PLATFORM_SOURCE_VPN", "vpn" },
        { NM_PLATFORM_SOURCE_DHCP, "NM_PLATFORM_SOURCE_DHCP", "dhcp" },
        { NM_PLATFORM_SOURCE_RDISC, "NM_PLATFORM_SOURCE_RDISC", "rdisc" },
        { NM_PLATFORM_SOURCE_USER, "NM_PLATFORM_SOURCE_USER", "user" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMPlatformSource"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_rdisc_dhcp_level_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_RDISC_DHCP_LEVEL_UNKNOWN, "NM_RDISC_DHCP_LEVEL_UNKNOWN", "unknown" },
        { NM_RDISC_DHCP_LEVEL_NONE, "NM_RDISC_DHCP_LEVEL_NONE", "none" },
        { NM_RDISC_DHCP_LEVEL_OTHERCONF, "NM_RDISC_DHCP_LEVEL_OTHERCONF", "otherconf" },
        { NM_RDISC_DHCP_LEVEL_MANAGED, "NM_RDISC_DHCP_LEVEL_MANAGED", "managed" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMRDiscDHCPLevel"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_rdisc_preference_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_RDISC_PREFERENCE_INVALID, "NM_RDISC_PREFERENCE_INVALID", "invalid" },
        { NM_RDISC_PREFERENCE_LOW, "NM_RDISC_PREFERENCE_LOW", "low" },
        { NM_RDISC_PREFERENCE_MEDIUM, "NM_RDISC_PREFERENCE_MEDIUM", "medium" },
        { NM_RDISC_PREFERENCE_HIGH, "NM_RDISC_PREFERENCE_HIGH", "high" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMRDiscPreference"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_rdisc_config_map_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_RDISC_CONFIG_DHCP_LEVEL, "NM_RDISC_CONFIG_DHCP_LEVEL", "dhcp-level" },
        { NM_RDISC_CONFIG_GATEWAYS, "NM_RDISC_CONFIG_GATEWAYS", "gateways" },
        { NM_RDISC_CONFIG_ADDRESSES, "NM_RDISC_CONFIG_ADDRESSES", "addresses" },
        { NM_RDISC_CONFIG_ROUTES, "NM_RDISC_CONFIG_ROUTES", "routes" },
        { NM_RDISC_CONFIG_DNS_SERVERS, "NM_RDISC_CONFIG_DNS_SERVERS", "dns-servers" },
        { NM_RDISC_CONFIG_DNS_DOMAINS, "NM_RDISC_CONFIG_DNS_DOMAINS", "dns-domains" },
        { NM_RDISC_CONFIG_HOP_LIMIT, "NM_RDISC_CONFIG_HOP_LIMIT", "hop-limit" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMRDiscConfigMap"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_ppp_status_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_PPP_STATUS_UNKNOWN, "NM_PPP_STATUS_UNKNOWN", "unknown" },
        { NM_PPP_STATUS_DEAD, "NM_PPP_STATUS_DEAD", "dead" },
        { NM_PPP_STATUS_INITIALIZE, "NM_PPP_STATUS_INITIALIZE", "initialize" },
        { NM_PPP_STATUS_SERIALCONN, "NM_PPP_STATUS_SERIALCONN", "serialconn" },
        { NM_PPP_STATUS_DORMANT, "NM_PPP_STATUS_DORMANT", "dormant" },
        { NM_PPP_STATUS_ESTABLISH, "NM_PPP_STATUS_ESTABLISH", "establish" },
        { NM_PPP_STATUS_AUTHENTICATE, "NM_PPP_STATUS_AUTHENTICATE", "authenticate" },
        { NM_PPP_STATUS_CALLBACK, "NM_PPP_STATUS_CALLBACK", "callback" },
        { NM_PPP_STATUS_NETWORK, "NM_PPP_STATUS_NETWORK", "network" },
        { NM_PPP_STATUS_RUNNING, "NM_PPP_STATUS_RUNNING", "running" },
        { NM_PPP_STATUS_TERMINATE, "NM_PPP_STATUS_TERMINATE", "terminate" },
        { NM_PPP_STATUS_DISCONNECT, "NM_PPP_STATUS_DISCONNECT", "disconnect" },
        { NM_PPP_STATUS_HOLDOFF, "NM_PPP_STATUS_HOLDOFF", "holdoff" },
        { NM_PPP_STATUS_MASTER, "NM_PPP_STATUS_MASTER", "master" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMPPPStatus"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_agent_manager_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_AGENT_MANAGER_ERROR_SENDER_UNKNOWN, "NM_AGENT_MANAGER_ERROR_SENDER_UNKNOWN", "SenderUnknown" },
        { NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED, "NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED", "PermissionDenied" },
        { NM_AGENT_MANAGER_ERROR_SESSION_NOT_FOUND, "NM_AGENT_MANAGER_ERROR_SESSION_NOT_FOUND", "SessionNotFound" },
        { NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER, "NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER", "InvalidIdentifier" },
        { NM_AGENT_MANAGER_ERROR_NOT_REGISTERED, "NM_AGENT_MANAGER_ERROR_NOT_REGISTERED", "NotRegistered" },
        { NM_AGENT_MANAGER_ERROR_INTERNAL_ERROR, "NM_AGENT_MANAGER_ERROR_INTERNAL_ERROR", "InternalError" },
        { NM_AGENT_MANAGER_ERROR_NO_SECRETS, "NM_AGENT_MANAGER_ERROR_NO_SECRETS", "NoSecrets" },
        { NM_AGENT_MANAGER_ERROR_USER_CANCELED, "NM_AGENT_MANAGER_ERROR_USER_CANCELED", "UserCanceled" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMAgentManagerError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_secret_agent_capabilities_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SECRET_AGENT_CAPABILITY_NONE, "NM_SECRET_AGENT_CAPABILITY_NONE", "none" },
        { NM_SECRET_AGENT_CAPABILITY_VPN_HINTS, "NM_SECRET_AGENT_CAPABILITY_VPN_HINTS", "vpn-hints" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSecretAgentCapabilities"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_settings_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTINGS_ERROR_GENERAL, "NM_SETTINGS_ERROR_GENERAL", "GeneralError" },
        { NM_SETTINGS_ERROR_INVALID_CONNECTION, "NM_SETTINGS_ERROR_INVALID_CONNECTION", "InvalidConnection" },
        { NM_SETTINGS_ERROR_READ_ONLY_CONNECTION, "NM_SETTINGS_ERROR_READ_ONLY_CONNECTION", "ReadOnlyConnection" },
        { NM_SETTINGS_ERROR_INTERNAL_ERROR, "NM_SETTINGS_ERROR_INTERNAL_ERROR", "InternalError" },
        { NM_SETTINGS_ERROR_SECRETS_UNAVAILABLE, "NM_SETTINGS_ERROR_SECRETS_UNAVAILABLE", "SecretsUnavailable" },
        { NM_SETTINGS_ERROR_SECRETS_REQUEST_CANCELED, "NM_SETTINGS_ERROR_SECRETS_REQUEST_CANCELED", "SecretsRequestCanceled" },
        { NM_SETTINGS_ERROR_PERMISSION_DENIED, "NM_SETTINGS_ERROR_PERMISSION_DENIED", "PermissionDenied" },
        { NM_SETTINGS_ERROR_INVALID_SETTING, "NM_SETTINGS_ERROR_INVALID_SETTING", "InvalidSetting" },
        { NM_SETTINGS_ERROR_ADD_NOT_SUPPORTED, "NM_SETTINGS_ERROR_ADD_NOT_SUPPORTED", "AddNotSupported" },
        { NM_SETTINGS_ERROR_UPDATE_NOT_SUPPORTED, "NM_SETTINGS_ERROR_UPDATE_NOT_SUPPORTED", "UpdateNotSupported" },
        { NM_SETTINGS_ERROR_DELETE_NOT_SUPPORTED, "NM_SETTINGS_ERROR_DELETE_NOT_SUPPORTED", "DeleteNotSupported" },
        { NM_SETTINGS_ERROR_ADD_FAILED, "NM_SETTINGS_ERROR_ADD_FAILED", "AddFailed" },
        { NM_SETTINGS_ERROR_SAVE_HOSTNAME_NOT_SUPPORTED, "NM_SETTINGS_ERROR_SAVE_HOSTNAME_NOT_SUPPORTED", "SaveHostnameNotSupported" },
        { NM_SETTINGS_ERROR_SAVE_HOSTNAME_FAILED, "NM_SETTINGS_ERROR_SAVE_HOSTNAME_FAILED", "SaveHostnameFailed" },
        { NM_SETTINGS_ERROR_HOSTNAME_INVALID, "NM_SETTINGS_ERROR_HOSTNAME_INVALID", "HostnameInvalid" },
        { NM_SETTINGS_ERROR_UUID_EXISTS, "NM_SETTINGS_ERROR_UUID_EXISTS", "UuidExists" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingsError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_system_config_interface_capabilities_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SYSTEM_CONFIG_INTERFACE_CAP_NONE, "NM_SYSTEM_CONFIG_INTERFACE_CAP_NONE", "none" },
        { NM_SYSTEM_CONFIG_INTERFACE_CAP_MODIFY_CONNECTIONS, "NM_SYSTEM_CONFIG_INTERFACE_CAP_MODIFY_CONNECTIONS", "modify-connections" },
        { NM_SYSTEM_CONFIG_INTERFACE_CAP_MODIFY_HOSTNAME, "NM_SYSTEM_CONFIG_INTERFACE_CAP_MODIFY_HOSTNAME", "modify-hostname" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSystemConfigInterfaceCapabilities"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_system_config_interface_prop_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SYSTEM_CONFIG_INTERFACE_PROP_FIRST, "NM_SYSTEM_CONFIG_INTERFACE_PROP_FIRST", "first" },
        { NM_SYSTEM_CONFIG_INTERFACE_PROP_NAME, "NM_SYSTEM_CONFIG_INTERFACE_PROP_NAME", "name" },
        { NM_SYSTEM_CONFIG_INTERFACE_PROP_INFO, "NM_SYSTEM_CONFIG_INTERFACE_PROP_INFO", "info" },
        { NM_SYSTEM_CONFIG_INTERFACE_PROP_CAPABILITIES, "NM_SYSTEM_CONFIG_INTERFACE_PROP_CAPABILITIES", "capabilities" },
        { NM_SYSTEM_CONFIG_INTERFACE_PROP_HOSTNAME, "NM_SYSTEM_CONFIG_INTERFACE_PROP_HOSTNAME", "hostname" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSystemConfigInterfaceProp"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_ap_support_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { AP_SUPPORT_UNKNOWN, "AP_SUPPORT_UNKNOWN", "unknown" },
        { AP_SUPPORT_NO, "AP_SUPPORT_NO", "no" },
        { AP_SUPPORT_YES, "AP_SUPPORT_YES", "yes" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("ApSupport"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_opt_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { TYPE_INVALID, "TYPE_INVALID", "invalid" },
        { TYPE_INT, "TYPE_INT", "int" },
        { TYPE_BYTES, "TYPE_BYTES", "bytes" },
        { TYPE_UTF8, "TYPE_UTF8", "utf8" },
        { TYPE_KEYWORD, "TYPE_KEYWORD", "keyword" },
        { TYPE_STRING, "TYPE_STRING", "string" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("OptType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_manager_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VPN_MANAGER_ERROR_DEVICE_NOT_ACTIVE, "NM_VPN_MANAGER_ERROR_DEVICE_NOT_ACTIVE", "BaseDeviceNotActive" },
        { NM_VPN_MANAGER_ERROR_CONNECTION_INVALID, "NM_VPN_MANAGER_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_VPN_MANAGER_ERROR_SERVICE_INVALID, "NM_VPN_MANAGER_ERROR_SERVICE_INVALID", "ServiceInvalid" },
        { NM_VPN_MANAGER_ERROR_SERVICE_START_FAILED, "NM_VPN_MANAGER_ERROR_SERVICE_START_FAILED", "ServiceStartFailed" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVPNManagerError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_dcb_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DCB_ERROR_UNKNOWN, "NM_DCB_ERROR_UNKNOWN", "unknown" },
        { NM_DCB_ERROR_INTERNAL, "NM_DCB_ERROR_INTERNAL", "internal" },
        { NM_DCB_ERROR_BAD_CONFIG, "NM_DCB_ERROR_BAD_CONFIG", "bad-config" },
        { NM_DCB_ERROR_HELPER_NOT_FOUND, "NM_DCB_ERROR_HELPER_NOT_FOUND", "helper-not-found" },
        { NM_DCB_ERROR_HELPER_FAILED, "NM_DCB_ERROR_HELPER_FAILED", "helper-failed" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDcbError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_dispatcher_action_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { DISPATCHER_ACTION_HOSTNAME, "DISPATCHER_ACTION_HOSTNAME", "hostname" },
        { DISPATCHER_ACTION_PRE_UP, "DISPATCHER_ACTION_PRE_UP", "pre-up" },
        { DISPATCHER_ACTION_UP, "DISPATCHER_ACTION_UP", "up" },
        { DISPATCHER_ACTION_PRE_DOWN, "DISPATCHER_ACTION_PRE_DOWN", "pre-down" },
        { DISPATCHER_ACTION_DOWN, "DISPATCHER_ACTION_DOWN", "down" },
        { DISPATCHER_ACTION_VPN_PRE_UP, "DISPATCHER_ACTION_VPN_PRE_UP", "vpn-pre-up" },
        { DISPATCHER_ACTION_VPN_UP, "DISPATCHER_ACTION_VPN_UP", "vpn-up" },
        { DISPATCHER_ACTION_VPN_PRE_DOWN, "DISPATCHER_ACTION_VPN_PRE_DOWN", "vpn-pre-down" },
        { DISPATCHER_ACTION_VPN_DOWN, "DISPATCHER_ACTION_VPN_DOWN", "vpn-down" },
        { DISPATCHER_ACTION_DHCP4_CHANGE, "DISPATCHER_ACTION_DHCP4_CHANGE", "dhcp4-change" },
        { DISPATCHER_ACTION_DHCP6_CHANGE, "DISPATCHER_ACTION_DHCP6_CHANGE", "dhcp6-change" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("DispatcherAction"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_auth_call_result_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_AUTH_CALL_RESULT_UNKNOWN, "NM_AUTH_CALL_RESULT_UNKNOWN", "unknown" },
        { NM_AUTH_CALL_RESULT_YES, "NM_AUTH_CALL_RESULT_YES", "yes" },
        { NM_AUTH_CALL_RESULT_AUTH, "NM_AUTH_CALL_RESULT_AUTH", "auth" },
        { NM_AUTH_CALL_RESULT_NO, "NM_AUTH_CALL_RESULT_NO", "no" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMAuthCallResult"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_manager_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_MANAGER_ERROR_UNKNOWN_CONNECTION, "NM_MANAGER_ERROR_UNKNOWN_CONNECTION", "UnknownConnection" },
        { NM_MANAGER_ERROR_UNKNOWN_DEVICE, "NM_MANAGER_ERROR_UNKNOWN_DEVICE", "UnknownDevice" },
        { NM_MANAGER_ERROR_UNMANAGED_DEVICE, "NM_MANAGER_ERROR_UNMANAGED_DEVICE", "UnmanagedDevice" },
        { NM_MANAGER_ERROR_SYSTEM_CONNECTION, "NM_MANAGER_ERROR_SYSTEM_CONNECTION", "SystemConnection" },
        { NM_MANAGER_ERROR_PERMISSION_DENIED, "NM_MANAGER_ERROR_PERMISSION_DENIED", "PermissionDenied" },
        { NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE, "NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE", "ConnectionNotActive" },
        { NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE, "NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE", "AlreadyAsleepOrAwake" },
        { NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED, "NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED", "AlreadyEnabledOrDisabled" },
        { NM_MANAGER_ERROR_UNSUPPORTED_CONNECTION_TYPE, "NM_MANAGER_ERROR_UNSUPPORTED_CONNECTION_TYPE", "UnsupportedConnectionType" },
        { NM_MANAGER_ERROR_DEPENDENCY_FAILED, "NM_MANAGER_ERROR_DEPENDENCY_FAILED", "DependencyFailed" },
        { NM_MANAGER_ERROR_AUTOCONNECT_NOT_ALLOWED, "NM_MANAGER_ERROR_AUTOCONNECT_NOT_ALLOWED", "AutoconnectNotAllowed" },
        { NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE, "NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE", "ConnectionAlreadyActive" },
        { NM_MANAGER_ERROR_INTERNAL, "NM_MANAGER_ERROR_INTERNAL", "Internal" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMManagerError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_rf_kill_state_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { RFKILL_UNBLOCKED, "RFKILL_UNBLOCKED", "unblocked" },
        { RFKILL_SOFT_BLOCKED, "RFKILL_SOFT_BLOCKED", "soft-blocked" },
        { RFKILL_HARD_BLOCKED, "RFKILL_HARD_BLOCKED", "hard-blocked" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("RfKillState"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_rf_kill_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { RFKILL_TYPE_WLAN, "RFKILL_TYPE_WLAN", "wlan" },
        { RFKILL_TYPE_WWAN, "RFKILL_TYPE_WWAN", "wwan" },
        { RFKILL_TYPE_WIMAX, "RFKILL_TYPE_WIMAX", "wimax" },
        { RFKILL_TYPE_UNKNOWN, "RFKILL_TYPE_UNKNOWN", "unknown" },
        { RFKILL_TYPE_MAX, "RFKILL_TYPE_MAX", "max" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("RfKillType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_session_monitor_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SESSION_MONITOR_ERROR_IO_ERROR, "NM_SESSION_MONITOR_ERROR_IO_ERROR", "IOError" },
        { NM_SESSION_MONITOR_ERROR_MALFORMED_DATABASE, "NM_SESSION_MONITOR_ERROR_MALFORMED_DATABASE", "MalformedDatabase" },
        { NM_SESSION_MONITOR_ERROR_UNKNOWN_USER, "NM_SESSION_MONITOR_ERROR_UNKNOWN_USER", "UnknownUser" },
        { NM_SESSION_MONITOR_ERROR_NO_DATABASE, "NM_SESSION_MONITOR_ERROR_NO_DATABASE", "NoDatabase" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSessionMonitorError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_wimax_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_WIMAX_ERROR_CONNECTION_NOT_WIMAX, "NM_WIMAX_ERROR_CONNECTION_NOT_WIMAX", "ConnectionNotWimax" },
        { NM_WIMAX_ERROR_CONNECTION_INVALID, "NM_WIMAX_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { NM_WIMAX_ERROR_CONNECTION_INCOMPATIBLE, "NM_WIMAX_ERROR_CONNECTION_INCOMPATIBLE", "ConnectionIncompatible" },
        { NM_WIMAX_ERROR_NSP_NOT_FOUND, "NM_WIMAX_ERROR_NSP_NOT_FOUND", "NspNotFound" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMWimaxError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}



