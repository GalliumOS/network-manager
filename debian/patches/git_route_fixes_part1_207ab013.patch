From 3e33a5a6c553ba9f8d8c888b127e86ad3b462e7d Mon Sep 17 00:00:00 2001
From: Thomas Haller <thaller@redhat.com>
Date: Mon, 22 Dec 2014 15:10:22 +0100
Subject: ifcfg-rh: support ipvx.route-metric property as IPVX_ROUTE_METRIC

Write ipv4.route-metric and ipv6.route-metric property of
NMSettingConnection as IPV4_ROUTE_METRIC and IPV6_ROUTE_METRIC,
respectively.

---
 src/NetworkManagerUtils.h                                                |   15 ++++++
 src/platform/nm-linux-platform.c                                         |   23 +++++++++-
 6 files changed, 63 insertions(+), 5 deletions(-)

Index: b/src/platform/nm-linux-platform.c
===================================================================
--- a/src/platform/nm-linux-platform.c
+++ b/src/platform/nm-linux-platform.c
@@ -3633,6 +3633,8 @@ ip6_route_add (NMPlatform *platform, int
                struct in6_addr network, int plen, struct in6_addr gateway,
                int metric, int mss)
 {
+	metric = nm_utils_ip6_route_metric_normalize (metric);
+
 	return add_object (platform, build_rtnl_route (AF_INET6, ifindex, source, &network, plen, &gateway, metric, mss));
 }
 
@@ -3651,7 +3653,7 @@ route_search_cache (struct nl_cache *cac
 		if (!_route_match (rtnlroute, family, ifindex))
 			continue;
 
-		if (metric && metric != rtnl_route_get_priority (rtnlroute))
+		if (metric != rtnl_route_get_priority (rtnlroute))
 			continue;
 
 		dst = rtnl_route_get_dst (rtnlroute);
@@ -3672,7 +3674,7 @@ route_search_cache (struct nl_cache *cac
 }
 
 static gboolean
-refresh_route (NMPlatform *platform, int family, int ifindex, const void *network, int plen, int metric)
+refresh_route (NMPlatform *platform, int family, int ifindex, const void *network, int plen, guint32 metric)
 {
 	struct nl_cache *cache;
 	auto_nl_object struct rtnl_route *cached_object = NULL;
@@ -3698,6 +3700,19 @@ ip4_route_delete (NMPlatform *platform,
 
 	cache = choose_cache_by_type (platform, OBJECT_TYPE_IP4_ROUTE);
 
+	if (metric == 0) {
+		/* Deleting an IPv4 route with metric 0 does not only delete an exectly matching route.
+		 * If no route with metric 0 exists, it might delete another route to the same destination.
+		 * For nm_platform_ip4_route_delete() we don't want this semantic.
+		 *
+		 * Instead, re-fetch the route from kernel, and if that fails, there is nothing to do.
+		 * On success, there is still a race that we might end up deleting the wrong route. */
+		if (!refresh_object (platform, (struct nl_object *) route, FALSE, NM_PLATFORM_REASON_INTERNAL)) {
+			rtnl_route_put ((struct rtnl_route *) route);
+			return TRUE;
+		}
+	}
+
 	/* when deleting an IPv4 route, several fields of the provided route must match.
 	 * Lookup in the cache so that we hopefully get the right values. */
 	cached_object = (struct rtnl_route *) nl_cache_search (cache, route);
@@ -3750,6 +3765,8 @@ ip6_route_delete (NMPlatform *platform,
 {
 	struct in6_addr gateway = IN6ADDR_ANY_INIT;
 
+	metric = nm_utils_ip6_route_metric_normalize (metric);
+
 	return delete_object (platform, build_rtnl_route (AF_INET6, ifindex, NM_PLATFORM_SOURCE_UNKNOWN ,&network, plen, &gateway, metric, 0), FALSE) &&
 	    refresh_route (platform, AF_INET6, ifindex, &network, plen, metric);
 }
@@ -3777,6 +3794,8 @@ ip4_route_exists (NMPlatform *platform,
 static gboolean
 ip6_route_exists (NMPlatform *platform, int ifindex, struct in6_addr network, int plen, int metric)
 {
+	metric = nm_utils_ip6_route_metric_normalize (metric);
+
 	return ip_route_exists (platform, AF_INET6, ifindex, &network, plen, metric);
 }
 
Index: b/src/NetworkManagerUtils.h
===================================================================
--- a/src/NetworkManagerUtils.h
+++ b/src/NetworkManagerUtils.h
@@ -38,6 +38,21 @@ gboolean nm_ethernet_address_is_valid (c
 in_addr_t nm_utils_ip4_address_clear_host_address (in_addr_t addr, guint8 plen);
 void nm_utils_ip6_address_clear_host_address (struct in6_addr *dst, const struct in6_addr *src, guint8 plen);
 
+/**
+ * nm_utils_ip6_route_metric_normalize:
+ * @metric: the route metric
+ *
+ * For IPv6 route, kernel treats the value 0 as IP6_RT_PRIO_USER (1024).
+ * Thus, when comparing metric (values), we want to treat zero as NM_PLATFORM_ROUTE_METRIC_DEFAULT.
+ *
+ * Returns: @metric, if @metric is not zero, otherwise 1024.
+ */
+static inline guint32
+nm_utils_ip6_route_metric_normalize (guint32 metric)
+{
+	return metric ? metric : 1024 /*NM_PLATFORM_ROUTE_METRIC_DEFAULT*/;
+}
+
 int nm_spawn_process (const char *args);
 
 /* macro to return strlen() of a compile time string. */
