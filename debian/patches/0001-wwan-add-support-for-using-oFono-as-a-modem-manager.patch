From 7469d3c11789a6c42f020c64214b813a925b5417 Mon Sep 17 00:00:00 2001
From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Date: Tue, 11 Nov 2014 22:20:30 -0500
Subject: [PATCH] wwan: add support for using oFono as a modem manager

Signed-off-by: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
---
 configure.ac                        |    9 
 src/NetworkManagerUtils.c           |   18 
 src/devices/wwan/Makefile.am        |    7 
 src/devices/wwan/nm-modem-manager.c |  191 ++++
 src/devices/wwan/nm-modem-ofono.c   | 1378 ++++++++++++++++++++++++++++++++++++
 src/devices/wwan/nm-modem-ofono.h   |   64 +
 6 files changed, 1655 insertions(+), 12 deletions(-)
 create mode 100644 src/devices/wwan/nm-modem-ofono.c
 create mode 100644 src/devices/wwan/nm-modem-ofono.h

Index: network-manager-0.9.10.0/configure.ac
===================================================================
--- network-manager-0.9.10.0.orig/configure.ac
+++ network-manager-0.9.10.0/configure.ac
@@ -593,6 +593,15 @@ else
 fi
 AM_CONDITIONAL(WITH_MODEM_MANAGER_1, test "${with_modem_manager_1}" = "yes")
 
+# OFONO
+AC_ARG_WITH(ofono, AS_HELP_STRING([--with-ofono], [Enable oFono support]),,[with_ofono=yes])
+if (test "${with_ofono}" = "yes"); then
+    AC_DEFINE(WITH_OFONO, 1, [Define if you have oFono support])
+else
+    AC_DEFINE(WITH_OFONO, 0, [Define if you have oFono support])
+fi
+AM_CONDITIONAL(WITH_OFONO, test "${with_ofono}" = "yes")
+
 # DHCP client support
 AC_ARG_WITH([dhclient], AS_HELP_STRING([--with-dhclient=yes|no|path], [Enable dhclient 4.x support]))
 AC_ARG_WITH([dhcpcd], AS_HELP_STRING([--with-dhcpcd=yes|no|path], [Enable dhcpcd 4.x support]))
Index: network-manager-0.9.10.0/src/devices/wwan/Makefile.am
===================================================================
--- network-manager-0.9.10.0.orig/src/devices/wwan/Makefile.am
+++ network-manager-0.9.10.0/src/devices/wwan/Makefile.am
@@ -49,6 +49,13 @@ libnm_wwan_la_SOURCES += \
 	nm-modem-broadband.h
 endif
 
+if WITH_OFONO
+libnm_wwan_la_SOURCES += \
+	nm-modem-ofono.c \
+	nm-modem-ofono.h \
+	$(NULL)
+endif
+
 WWAN_SYMBOL_VIS_FILE=$(srcdir)/wwan-exports.ver
 
 libnm_wwan_la_LDFLAGS = \
Index: network-manager-0.9.10.0/src/devices/wwan/nm-modem-manager.c
===================================================================
--- network-manager-0.9.10.0.orig/src/devices/wwan/nm-modem-manager.c
+++ network-manager-0.9.10.0/src/devices/wwan/nm-modem-manager.c
@@ -17,7 +17,7 @@
  *
  * Copyright (C) 2009 - 2014 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
- * Copyright (C) 2009 Canonical Ltd.
+ * Copyright (C) 2009 - 2013 Canonical Ltd.
  */
 
 #include <string.h>
@@ -35,6 +35,11 @@
 #include "nm-modem-broadband.h"
 #endif
 
+#if WITH_OFONO
+#include "nm-dbus-manager.h"
+#include "nm-modem-ofono.h"
+#endif
+
 #define MODEM_POKE_INTERVAL 120
 
 G_DEFINE_TYPE (NMModemManager, nm_modem_manager, G_TYPE_OBJECT)
@@ -57,6 +62,10 @@ struct _NMModemManagerPrivate {
 	guint modem_manager_1_object_removed_id;
 #endif
 
+#if WITH_OFONO
+	DBusGProxy *ofono_proxy;
+#endif
+
 	/* Common */
 	GHashTable *modems;
 };
@@ -235,6 +244,156 @@ enumerate_devices_done (DBusGProxy *prox
 static void clear_modem_manager_1_support (NMModemManager *self);
 #endif
 
+#if WITH_OFONO
+static void
+ofono_create_modem (NMModemManager *self, const char *path)
+{
+	NMModem *modem = NULL;
+	DBusGProxy *proxy;
+	GError *err = NULL;
+	GValue value = { 0, };
+
+	proxy = dbus_g_proxy_new_for_name (nm_dbus_manager_get_connection (self->priv->dbus_mgr),
+	                                   OFONO_DBUS_SERVICE,
+	                                   path,
+	                                   OFONO_DBUS_INTERFACE_MODEM);
+
+	/* Create a simple TRUE gvalue boolean */
+	g_value_init (&value, G_TYPE_BOOLEAN);
+	g_value_set_boolean (&value, TRUE);
+
+	/* Mark the modem as powered */
+	if (!dbus_g_proxy_call_with_timeout (proxy, "SetProperty", 15000, &err,
+	                                     G_TYPE_STRING, "Powered",
+	                                     G_TYPE_VALUE, &value,
+	                                     G_TYPE_INVALID,
+	                                     G_TYPE_INVALID)) {
+		nm_log_warn (LOGD_MB, "could not mark modem as powered: %s %s",
+		             err ? dbus_g_error_get_name (err) : "(none)",
+		             err ? err->message : "(unknown)");
+		g_clear_error (&err);
+		/* Don't fail the creation here, some modems are weird. */
+	}
+
+	if (g_hash_table_lookup (self->priv->modems, path)) {
+		nm_log_warn (LOGD_MB, "modem with path %s already exists, ignoring", path);
+		return;
+	}
+
+	/* Create modem instance */
+	modem = nm_modem_ofono_new (path);
+	if (modem)
+		handle_new_modem (self, modem);
+	else
+		nm_log_warn (LOGD_MB, "Failed to create oFono modem for %s", path);
+}
+
+static void
+ofono_modem_added (DBusGProxy *proxy, const char *path, GHashTable *props, gpointer user_data)
+{
+	ofono_create_modem (NM_MODEM_MANAGER (user_data), path);
+}
+
+static void
+ofono_modem_removed (DBusGProxy *proxy,
+                     const char *path,
+                     gpointer user_data)
+{
+	NMModemManager *self = NM_MODEM_MANAGER (user_data);
+	NMModem *modem;
+
+	modem = (NMModem *) g_hash_table_lookup (self->priv->modems, path);
+	if (!modem)
+		return;
+
+	nm_modem_emit_removed (modem);
+	g_hash_table_remove (self->priv->modems, path);
+}
+
+#define OFONO_DBUS_MODEM_ENTRY (dbus_g_type_get_struct ("GValueArray", DBUS_TYPE_G_OBJECT_PATH, DBUS_TYPE_G_MAP_OF_VARIANT, G_TYPE_INVALID))
+#define OFONO_DBUS_MODEM_ENTRIES (dbus_g_type_get_collection ("GPtrArray", OFONO_DBUS_MODEM_ENTRY))
+
+static void
+ofono_enumerate_devices_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer data)
+{
+	NMModemManager *manager = NM_MODEM_MANAGER (data);
+	GPtrArray *modems;
+	GError *error = NULL;
+
+	if (!dbus_g_proxy_end_call (proxy, call_id, &error,
+	                            OFONO_DBUS_MODEM_ENTRIES, &modems,
+	                            G_TYPE_INVALID)) {
+		nm_log_warn (LOGD_MB, "could not get modem list: %s", error->message);
+		g_error_free (error);
+	} else {
+		int i;
+
+		for (i = 0; i < modems->len; i++) {
+			GValueArray *item = g_ptr_array_index (modems, i);
+			GValue *tmp;
+			const char *path;
+
+			tmp = g_value_array_get_nth (item, 0);
+			path = g_value_get_boxed (tmp);
+
+			ofono_create_modem (manager, path);
+
+			g_value_array_free (item);
+		}
+
+		g_ptr_array_free (modems, TRUE);
+	}
+}
+static void
+ofono_appeared (NMModemManager *self)
+{
+	nm_log_info (LOGD_MB, "ofono is now available");
+
+	self->priv->ofono_proxy = dbus_g_proxy_new_for_name (nm_dbus_manager_get_connection (self->priv->dbus_mgr),
+	                                                     OFONO_DBUS_SERVICE, OFONO_DBUS_PATH, OFONO_DBUS_INTERFACE);
+
+	dbus_g_object_register_marshaller (g_cclosure_marshal_generic,
+	                                   G_TYPE_NONE,
+	                                   DBUS_TYPE_G_OBJECT_PATH, DBUS_TYPE_G_MAP_OF_VARIANT,
+	                                   G_TYPE_INVALID);
+	dbus_g_proxy_add_signal (self->priv->ofono_proxy, "ModemAdded",
+	                         DBUS_TYPE_G_OBJECT_PATH,
+	                         DBUS_TYPE_G_MAP_OF_VARIANT,
+	                         G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (self->priv->ofono_proxy, "ModemAdded",
+	                             G_CALLBACK (ofono_modem_added), self,
+	                             NULL);
+
+	dbus_g_proxy_add_signal (self->priv->ofono_proxy, "ModemRemoved",
+	                         DBUS_TYPE_G_OBJECT_PATH,
+	                         G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (self->priv->ofono_proxy, "ModemRemoved",
+	                             G_CALLBACK (ofono_modem_removed), self,
+	                             NULL);
+
+	dbus_g_proxy_begin_call (self->priv->ofono_proxy,
+	                         "GetModems",
+	                         ofono_enumerate_devices_done,
+	                         self, NULL, G_TYPE_INVALID);
+}
+
+static void
+clear_ofono_support (NMModemManager *self)
+{
+	if (self->priv->ofono_proxy) {
+		g_object_unref (self->priv->ofono_proxy);
+		self->priv->ofono_proxy = NULL;
+	}
+}
+
+static void
+init_ofono_bus (NMModemManager *self)
+{
+	if (nm_dbus_manager_name_has_owner (self->priv->dbus_mgr, OFONO_DBUS_SERVICE))
+		ofono_appeared (self);
+}
+#endif
+
 static void
 modem_manager_appeared (NMModemManager *self, gboolean enumerate_devices)
 {
@@ -303,18 +462,22 @@ nm_modem_manager_name_owner_changed (NMD
 	gboolean old_owner_good;
 	gboolean new_owner_good;
 
-	/* Can't handle the signal if its not from the modem service */
-	if (strcmp (MM_OLD_DBUS_SERVICE, name) != 0)
-		return;
-
 	old_owner_good = (old_owner && strlen (old_owner));
 	new_owner_good = (new_owner && strlen (new_owner));
 
-	if (!old_owner_good && new_owner_good) {
-		modem_manager_appeared (NM_MODEM_MANAGER (user_data), FALSE);
-	} else if (old_owner_good && !new_owner_good) {
-		nm_log_info (LOGD_MB, "the modem manager disappeared");
-		modem_manager_disappeared (NM_MODEM_MANAGER (user_data));
+	if (strcmp (MM_OLD_DBUS_SERVICE, name) == 0) {
+		if (!old_owner_good && new_owner_good) {
+			modem_manager_appeared (NM_MODEM_MANAGER (user_data), FALSE);
+		} else if (old_owner_good && !new_owner_good) {
+			nm_log_info (LOGD_MB, "the modem manager disappeared");
+			modem_manager_disappeared (NM_MODEM_MANAGER (user_data));
+		}
+	} else if (strcmp (OFONO_DBUS_SERVICE, name) == 0) {
+		if (!old_owner_good && new_owner_good) {
+			ofono_appeared (NM_MODEM_MANAGER (user_data));
+		} else if (old_owner_good && !new_owner_good) {
+			nm_log_info (LOGD_MB, "ofono disappeared");
+		}
 	}
 }
 
@@ -708,6 +871,10 @@ nm_modem_manager_init (NMModemManager *s
 	else
 		modem_manager_disappeared (self);
 
+#if WITH_OFONO
+	init_ofono_bus (self);
+#endif
+
 #if WITH_MODEM_MANAGER_1
 	/* ModemManager >= 0.7 */
 	schedule_modem_manager_1_relaunch (self, 0);
@@ -722,6 +889,10 @@ dispose (GObject *object)
 	/* ModemManager < 0.7 */
 	clear_modem_manager_support (self);
 
+#if WITH_OFONO
+	clear_ofono_support (self);
+#endif
+
 #if WITH_MODEM_MANAGER_1
 	/* ModemManager >= 0.7 */
 	clear_modem_manager_1_support (self);
Index: network-manager-0.9.10.0/src/devices/wwan/nm-modem-ofono.c
===================================================================
--- /dev/null
+++ network-manager-0.9.10.0/src/devices/wwan/nm-modem-ofono.c
@@ -0,0 +1,1140 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2013 Canonical Ltd.
+ */
+
+#include "config.h"
+
+#include <string.h>
+#include <glib/gi18n.h>
+
+#include "nm-dbus-glib-types.h"
+#include "nm-modem-ofono.h"
+#include "nm-device.h"
+#include "nm-device-private.h"
+#include "nm-setting-connection.h"
+#include "nm-setting-gsm.h"
+#include "nm-settings-connection.h"
+#include "nm-enum-types.h"
+#include "nm-logging.h"
+#include "nm-modem.h"
+#include "nm-dbus-manager.h"
+#include "NetworkManagerUtils.h"
+
+G_DEFINE_TYPE (NMModemOfono, nm_modem_ofono, NM_TYPE_MODEM)
+
+#define NM_MODEM_OFONO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_MODEM_OFONO, NMModemOfonoPrivate))
+
+typedef struct {
+	GHashTable *connect_properties;
+
+	NMDBusManager *dbus_mgr;
+
+	DBusGProxy *modem_proxy;
+	DBusGProxy *connman_proxy;
+	DBusGProxy *context_proxy;
+	DBusGProxy *simmanager_proxy;
+
+	GError *property_error;
+
+	char **interfaces;
+	char *context_path;
+
+	gboolean modem_online;
+	gboolean gprs_attached;
+	gboolean gprs_powered;
+
+	NMIP4Config *ip4_config;
+
+	gboolean enabled;
+} NMModemOfonoPrivate;
+
+#define NM_OFONO_ERROR (nm_ofono_error_quark ())
+
+static GQuark
+nm_ofono_error_quark (void)
+{
+	static GQuark quark = 0;
+	if (!quark)
+		quark = g_quark_from_static_string ("nm-ofono-error");
+	return quark;
+}
+
+static gboolean
+ip_string_to_network_address (const gchar *str,
+                              guint32 *out)
+{
+	struct in_addr addr;
+
+	/* IP address */
+	if (inet_pton (AF_INET, str, &addr) <= 0)
+		return FALSE;
+
+	*out = (guint32)addr.s_addr;
+	return TRUE;
+}
+
+/* Disconnect stuff */
+typedef struct {
+	NMModemOfono *self;
+	gboolean warn;
+} SimpleDisconnectContext;
+
+static void
+simple_disconnect_context_free (SimpleDisconnectContext *ctx)
+{
+	g_object_unref (ctx->self);
+	g_slice_free (SimpleDisconnectContext, ctx);
+}
+
+static void
+disconnect_done (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
+{
+	SimpleDisconnectContext *ctx = (SimpleDisconnectContext*) user_data;
+	NMModemOfono *self = ctx->self;
+	NMModemState state = nm_modem_get_state (NM_MODEM (self));
+	GError *error = NULL;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	if (!dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID)) {
+		if (ctx->warn)
+			nm_log_warn (LOGD_MB, "(%s) failed to disconnect modem: %s",
+			             nm_modem_get_uid (NM_MODEM (self)),
+			             error && error->message ? error->message : "(unknown)");
+		g_clear_error (&error);
+	}
+
+	simple_disconnect_context_free (ctx);
+
+	if (state != NM_MODEM_STATE_SEARCHING)
+		nm_modem_set_state (NM_MODEM (self),
+		                    NM_MODEM_STATE_REGISTERED,
+		                    nm_modem_state_to_string (NM_MODEM_STATE_REGISTERED));
+}
+
+static void
+disconnect (NMModem *self,
+            gboolean warn)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	SimpleDisconnectContext *ctx;
+	GValue value = G_VALUE_INIT;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	ctx = g_slice_new (SimpleDisconnectContext);
+	ctx->self = g_object_ref (self);
+	ctx->warn = warn;
+
+	g_value_init (&value, G_TYPE_BOOLEAN);
+	g_value_set_boolean (&value, FALSE);
+
+	dbus_g_proxy_begin_call_with_timeout (priv->context_proxy,
+	                                      "SetProperty", disconnect_done,
+	                                      ctx, NULL, 20000,
+	                                      G_TYPE_STRING, "Active",
+	                                      G_TYPE_VALUE, &value,
+	                                      G_TYPE_INVALID);
+
+}
+
+static void
+deactivate (NMModem *_self, NMDevice *device)
+{
+	/* Chain up parent's */
+	NM_MODEM_CLASS (nm_modem_ofono_parent_class)->deactivate (_self, device);
+}
+
+DBusGProxy *
+get_ofono_proxy (NMModemOfono *self, const char *path, const char *interface)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	DBusGConnection *bus;
+	DBusGProxy *proxy;
+
+	bus = nm_dbus_manager_get_connection (priv->dbus_mgr);
+
+	proxy = dbus_g_proxy_new_for_name (bus,
+	                                   OFONO_DBUS_SERVICE,
+	                                   path,
+	                                   interface);
+
+	return proxy;
+}
+
+static void ofono_read_contexts (NMModemOfono *self);
+
+static void
+update_ofono_enabled (NMModemOfono *self,
+                      gboolean new_enabled)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	NMModemState new_state;
+	NMDeviceStateReason reason;
+
+	if (new_enabled == priv->enabled)
+		return;
+
+	if (new_enabled) {
+		new_state = NM_MODEM_STATE_REGISTERED;
+		reason = NM_DEVICE_STATE_REASON_NONE;
+		ofono_read_contexts (self);
+	} else {
+		new_state = NM_MODEM_STATE_SEARCHING;
+		reason = NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER;
+	}
+
+	nm_modem_set_state (NM_MODEM (self),
+	                    new_state,
+	                    nm_modem_state_to_string (new_state));
+
+	priv->enabled = new_enabled;
+
+	nm_log_info (LOGD_MB, "(%s) now in state: %s",
+	             nm_modem_get_path (NM_MODEM (self)),
+	             nm_modem_state_to_string(new_state));
+}
+
+static void
+get_ofono_conn_manager_properties_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	GError *error = NULL;
+	GHashTable *properties = NULL;
+	GValue *value = NULL;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	if (!dbus_g_proxy_end_call (proxy, call_id, &error,
+	                            DBUS_TYPE_G_MAP_OF_VARIANT, &properties,
+	                            G_TYPE_INVALID)) {
+		nm_log_warn (LOGD_MB, "failed get connection manager properties: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+		return;
+	}
+
+	value = g_hash_table_lookup (properties, "Attached");
+	if (value)
+		priv->gprs_attached = g_value_get_boolean (value);
+	else
+		nm_log_warn (LOGD_MB, "failed get GPRS state: unexpected reply type");
+	g_value_unset (value);
+
+	value = g_hash_table_lookup (properties, "Powered");
+	if (value)
+		priv->gprs_powered = g_value_get_boolean (value);
+	else
+		nm_log_warn (LOGD_MB, "failed get modem enabled state: unexpected reply type");
+	g_value_unset (value);
+
+	update_ofono_enabled (self, priv->modem_online
+	                            && priv->gprs_powered
+	                            && priv->gprs_attached);
+}
+
+static void
+get_ofono_conn_manager_properties (NMModemOfono *self)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+
+	dbus_g_proxy_begin_call_with_timeout (priv->connman_proxy,
+	                                      "GetProperties",
+	                                      get_ofono_conn_manager_properties_done,
+	                                      self, NULL, 20000,
+	                                      G_TYPE_INVALID);
+}
+
+static void
+ofono_conn_properties_changed (DBusGProxy *proxy,
+                               const char *key,
+                               GValue *value,
+                               gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	if (g_strcmp0 (key, "Powered") == 0 && G_VALUE_HOLDS_BOOLEAN (value)) {
+		priv->gprs_powered = g_value_get_boolean (value);
+	} else if (g_strcmp0 (key, "Attached") == 0 && G_VALUE_HOLDS_BOOLEAN (value)) {
+		priv->gprs_attached = g_value_get_boolean (value);
+	} else
+		/* No need to update enabled for other property changes */
+		return;
+
+	update_ofono_enabled (self, priv->modem_online
+	                            && priv->gprs_powered
+	                            && priv->gprs_attached);
+}
+
+static void
+ofono_read_imsi_contexts_done (DBusGProxy *proxy,
+                               DBusGProxyCall *call_id,
+                               gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	GError *error = NULL;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	if (!dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
+		nm_log_warn (LOGD_MB, "failed notify settings plugin of a new context: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+		return;
+	}
+}
+
+static void
+ofono_read_contexts (NMModemOfono *self)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	DBusGConnection *bus;
+	DBusGProxy *settings_proxy;
+	GHashTable *properties;
+	GError *error = NULL;
+	const char *imsi;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+	nm_log_info (LOGD_MB, "(%s): trying to read IMSI contexts from oFono files",
+	             nm_modem_get_path (NM_MODEM (self)));
+
+	bus = nm_dbus_manager_get_connection (priv->dbus_mgr);
+
+	dbus_g_proxy_call_with_timeout (priv->simmanager_proxy,
+	                                "GetProperties",
+	                                20000,
+	                                &error,
+	                                G_TYPE_INVALID,
+	                                DBUS_TYPE_G_MAP_OF_VARIANT, &properties,
+	                                G_TYPE_INVALID);
+
+	if (error) {
+		nm_log_warn (LOGD_MB, "Could not get SIM properties: %s",
+		             error && error->message ? error->message : "(unknown)");
+		g_clear_error (&error);
+	}
+
+	imsi = g_value_get_string (g_hash_table_lookup (properties, "SubscriberIdentity"));
+
+	settings_proxy = dbus_g_proxy_new_for_name (bus,
+	                                            "com.canonical.NMOfono",
+	                                            "/com/canonical/NMOfono",
+	                                            "com.canonical.NMOfono");
+
+	if (settings_proxy)
+		dbus_g_proxy_begin_call_with_timeout (settings_proxy,
+		                                      "ReadImsiContexts", ofono_read_imsi_contexts_done,
+		                                      self, NULL, 20000,
+		                                      G_TYPE_STRING, imsi,
+		                                      G_TYPE_INVALID);
+	else
+		nm_log_warn (LOGD_MB, "could not get proxy to the oFono Settings plugin.");
+}
+
+static void
+ofono_context_added (DBusGProxy *proxy,
+                     const char *path,
+                     GValue *prop,
+                     gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+
+	nm_log_dbg (LOGD_MB, "context %s added", path);
+
+	ofono_read_contexts (self);
+}
+
+static void
+ofono_context_removed (DBusGProxy *proxy, const char *path, gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+
+	nm_log_dbg (LOGD_MB, "context %s removed", path);
+}
+
+static void
+ofono_properties_changed (DBusGProxy *proxy,
+                          const char *key,
+                          GValue *value,
+                          gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+
+	nm_log_dbg (LOGD_MB, "in %s: %s", __func__, key);
+
+	if (g_strcmp0 (key, "Online") == 0 && G_VALUE_HOLDS_BOOLEAN (value)) {
+		priv->modem_online = g_value_get_boolean (value);
+		nm_log_info (LOGD_MB, "(%s) modem is now %s",
+		             nm_modem_get_path (NM_MODEM (self)),
+		             priv->modem_online ? "Online" : "Offline");
+		update_ofono_enabled (self, priv->modem_online
+		                            && priv->gprs_powered
+		                            && priv->gprs_attached);
+	} else if (g_strcmp0 (key, "Interfaces") == 0 && G_VALUE_HOLDS_BOXED (value)) {
+		gboolean found_simmanager = FALSE;
+		gboolean found_conn_manager = FALSE;
+		int i;
+
+		priv->interfaces = (char **) g_value_get_boxed (value);
+		nm_log_info (LOGD_MB, "(%s) updated available interfaces", nm_modem_get_path (NM_MODEM (self)));
+
+		for (i = 0; priv->interfaces[i]; i++) {
+			if (g_strrstr (priv->interfaces[i], "SimManager"))
+				found_simmanager = TRUE;
+			if (g_strrstr (priv->interfaces[i], "ConnectionManager"))
+				found_conn_manager = TRUE;
+		}
+
+		if (found_simmanager) {
+			if (!priv->simmanager_proxy) {
+				nm_log_info (LOGD_MB, "(%s): found new SimManager interface",
+				             nm_modem_get_path (NM_MODEM (self)));
+				priv->simmanager_proxy = get_ofono_proxy (self,
+				                                          nm_modem_get_path (NM_MODEM (self)),
+				                                          OFONO_DBUS_INTERFACE_SIM_MANAGER);
+			}
+		} else {
+			if (priv->simmanager_proxy) {
+				nm_log_info (LOGD_MB, "(%s): SimManager interface disappeared",
+				             nm_modem_get_path (NM_MODEM (self)));
+				g_object_unref (priv->simmanager_proxy);
+				priv->simmanager_proxy = NULL;
+			}
+		}
+
+		if (found_conn_manager) {
+			if (!priv->connman_proxy) {
+				nm_log_info (LOGD_MB, "(%s): found new ConnectionManager interface",
+				             nm_modem_get_path (NM_MODEM (self)));
+				priv->connman_proxy = get_ofono_proxy (self,
+				                                       nm_modem_get_path (NM_MODEM (self)),
+				                                       OFONO_DBUS_INTERFACE_CONNECTION_MANAGER);
+
+				if (priv->connman_proxy) {
+					get_ofono_conn_manager_properties (self);
+
+					dbus_g_proxy_add_signal (priv->connman_proxy, "PropertyChanged",
+					                         G_TYPE_STRING, G_TYPE_VALUE,
+					                         G_TYPE_INVALID);
+					dbus_g_proxy_connect_signal (priv->connman_proxy, "PropertyChanged",
+					                             G_CALLBACK (ofono_conn_properties_changed),
+					                             self,
+					                             NULL);
+
+					dbus_g_proxy_add_signal (priv->connman_proxy, "ContextAdded",
+					                         DBUS_TYPE_G_OBJECT_PATH, DBUS_TYPE_G_MAP_OF_VARIANT,
+					                         G_TYPE_INVALID);
+					dbus_g_proxy_connect_signal (priv->connman_proxy, "ContextAdded",
+					                             G_CALLBACK (ofono_context_added),
+					                             self,
+					                             NULL);
+					dbus_g_proxy_add_signal (priv->connman_proxy, "ContextRemoved",
+					                         DBUS_TYPE_G_OBJECT_PATH,
+					                         G_TYPE_INVALID);
+					dbus_g_proxy_connect_signal (priv->connman_proxy, "ContextRemoved",
+					                             G_CALLBACK (ofono_context_removed),
+					                             self,
+					                             NULL);
+				}
+			}
+		} else {
+			if (priv->connman_proxy) {
+				nm_log_info (LOGD_MB, "(%s): ConnectionManager interface disappeared",
+				             nm_modem_get_path (NM_MODEM (self)));
+				g_object_unref (priv->connman_proxy);
+				priv->connman_proxy = NULL;
+
+				/* The connection manager proxy disappeared, we should
+				 * consider the modem disabled.
+				 */
+				update_ofono_enabled (self, FALSE);
+				priv->gprs_powered = FALSE;
+				priv->gprs_attached = FALSE;
+			}
+		}
+	}
+}
+
+NMModem *
+nm_modem_ofono_new (const char *path)
+{
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+	g_return_val_if_fail (path != NULL, NULL);
+
+	nm_log_dbg (LOGD_MB, "in %s: path %s", __func__, path);
+
+	return (NMModem *) g_object_new (NM_TYPE_MODEM_OFONO,
+	                                 NM_MODEM_PATH, path,
+	                                 NM_MODEM_UID, (path + 1),
+	                                 NM_MODEM_CONTROL_PORT, "ofono", /* mandatory */
+	                                 NM_MODEM_IP_METHOD, MM_MODEM_IP_METHOD_STATIC,
+	                                 NM_MODEM_STATE, NM_MODEM_STATE_INITIALIZING,
+	                                 NULL);
+}
+
+static void
+stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	GError *error = NULL;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	if (priv->connect_properties) {
+		g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = NULL;
+	}
+
+	if (!dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID)) {
+		nm_log_warn (LOGD_MB, "OFONO connection failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE,
+		                       NM_DEVICE_STATE_REASON_MODEM_BUSY);
+
+		/*
+		 * FIXME: add code to check for InProgress so that the
+		 * connection doesn't continue to try and activate,
+		 * leading to the connection being disabled, and a 5m
+		 * timeout...
+		 */
+
+		g_error_free (error);
+	}
+}
+
+static void
+ofono_context_get_ip_properties (NMModemOfono *self)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	NMPlatformIP4Address addr;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
+	GHashTable *properties, *ip_settings;
+	GError *error = NULL;
+	GType prop_dict;
+	const gchar *address_string, *gateway_string, *netmask_string, *iface;
+	gchar **dns;
+	const gchar *mms_proxy;
+	gpointer settings;
+	gboolean ret = FALSE;
+	guint32 address_network, gateway_network;
+	guint i;
+	guint prefix = 0;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	prop_dict = dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE);
+	dbus_g_proxy_call_with_timeout (priv->context_proxy,
+	                                "GetProperties",
+	                                20000, &error,
+	                                G_TYPE_INVALID,
+	                                prop_dict, &properties,
+	                                G_TYPE_INVALID);
+
+	if (!error) {
+		settings = g_hash_table_lookup (properties, "Settings");
+		if (settings && G_VALUE_HOLDS_BOXED (settings)) {
+			ip_settings = (GHashTable*) g_value_get_boxed (settings);
+
+			if (nm_modem_get_state (NM_MODEM (self)) == NM_MODEM_STATE_CONNECTED
+			    && g_hash_table_size(ip_settings) <= 0) {
+				g_signal_emit_by_name (self, NM_MODEM_PPP_FAILED, NM_DEVICE_STATE_REASON_PPP_FAILED);
+				return;
+			}
+
+			nm_log_info (LOGD_MB, "(%s): IPv4 static configuration:",
+			             nm_modem_get_uid (NM_MODEM (self)));
+
+			iface = g_value_get_string (g_hash_table_lookup (ip_settings, "Interface"));
+			if (iface)
+				g_object_set (self, NM_MODEM_DATA_PORT, iface, NULL);
+
+			if (priv->ip4_config)
+				g_object_unref (priv->ip4_config);
+			priv->ip4_config = nm_ip4_config_new ();
+			memset (&addr, 0, sizeof (addr));
+
+			address_string = g_value_get_string (g_hash_table_lookup (ip_settings, "Address"));
+			if (address_string) {
+				if (ip_string_to_network_address (address_string, &address_network)) {
+					addr.address = address_network;
+					addr.source = NM_PLATFORM_SOURCE_WWAN;
+				}
+			} else
+				goto out;
+
+			/* retrieve netmask and convert to prefix value */
+			netmask_string = g_value_get_string (g_hash_table_lookup (ip_settings, "Netmask"));
+			if (ip_string_to_network_address (netmask_string, &address_network)) {
+				prefix = nm_utils_ip4_netmask_to_prefix (address_network);
+				if (prefix > 0)
+					addr.plen = prefix;
+			} else
+				goto out;
+
+			nm_log_info (LOGD_MB, "  address %s/%d", address_string, prefix);
+			nm_ip4_config_add_address (priv->ip4_config, &addr);
+
+			gateway_string = g_value_get_string (g_hash_table_lookup (ip_settings, "Gateway"));
+			if (gateway_string) {
+				if (ip_string_to_network_address (gateway_string, &gateway_network)) {
+					nm_log_info (LOGD_MB, "  gateway %s", gateway_string);
+					nm_ip4_config_set_gateway (priv->ip4_config, gateway_network);
+				}
+			} else
+				goto out;
+
+			/* DNS servers */
+			dns = (char **) g_value_get_boxed (g_hash_table_lookup (ip_settings, "DomainNameServers"));
+			for (i = 0; dns[i]; i++) {
+				if (   ip_string_to_network_address (dns[i], &address_network)
+				    && address_network > 0) {
+				    nm_ip4_config_add_nameserver (priv->ip4_config, address_network);
+				    nm_log_info (LOGD_MB, "  DNS %s", dns[i]);
+				}
+			}
+
+			/* Handle the case for a shared internet and MMS context */
+			mms_proxy = g_value_get_string (g_hash_table_lookup (properties, "MessageProxy"));
+			if (mms_proxy) {
+				nm_log_info (LOGD_MB, "  mms proxy: %s", mms_proxy);
+
+				/* If the value can't be mapped to a guint32, it's probably not
+				 * an IP address; so we could access it via *any* internet
+				 * connection anyway, no need for a specific host route.
+				 */
+				if (ip_string_to_network_address (mms_proxy, &address_network)) {
+					NMPlatformIP4Route mms_route;
+
+					mms_route.network = address_network;
+					mms_route.plen = 32;
+					mms_route.gateway = gateway_network;
+
+					/* Setting a very low metric as MMS should go through
+					 * the 3G connection...
+					 */
+					mms_route.metric = 1;
+
+					nm_ip4_config_add_route (priv->ip4_config, &mms_route);
+				}
+			}
+
+			ret = TRUE;
+		}
+	}
+
+out:
+	if (!ret) {
+		if (error) {
+			reason = NM_DEVICE_STATE_REASON_CONFIG_FAILED;
+			g_clear_error (&error);
+		} else {
+			reason = NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE;
+		}
+	}
+
+	if (nm_modem_get_state (NM_MODEM (self)) != NM_MODEM_STATE_CONNECTED)
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, ret, reason);
+}
+
+static void
+context_properties_changed (DBusGProxy *proxy,
+                            const char *key,
+                            GValue *value,
+                            gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+
+	if (g_strcmp0("Settings", key) == 0) {
+		ofono_context_get_ip_properties (self);
+	}
+}
+
+static void
+do_context_activate (NMModemOfono *self, char *context_path)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	GValue value = G_VALUE_INIT;
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_MODEM_OFONO (self), FALSE);
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	g_value_init (&value, G_TYPE_BOOLEAN);
+	g_value_set_boolean (&value, TRUE);
+
+	if (priv->context_proxy)
+		g_object_unref (priv->context_proxy);
+
+	priv->context_proxy = get_ofono_proxy (self,
+	                                       context_path,
+	                                       OFONO_DBUS_INTERFACE_CONNECTION_CONTEXT);
+
+	if (!priv->context_proxy) {
+		nm_log_err (LOGD_MB, "could not bring up connection context proxy");
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE,
+		                       NM_DEVICE_STATE_REASON_MODEM_BUSY);
+		return;
+	}
+
+	if (!priv->gprs_attached) {
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE,
+		                       NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER);
+		return;
+	}
+
+	if (priv->ip4_config) {
+		/* We have an old copy of the settings from a previous activation,
+		 * clear it so that we can gate getting the IP config from oFono
+		 * on whether or not we have already received them
+		 */
+		g_object_unref (priv->ip4_config);
+		priv->ip4_config = NULL;
+	}
+
+	dbus_g_proxy_add_signal (priv->context_proxy, "PropertyChanged",
+	                         G_TYPE_STRING, G_TYPE_VALUE,
+	                         G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (priv->context_proxy, "PropertyChanged",
+	                             G_CALLBACK (context_properties_changed),
+	                             self,
+	                             NULL);
+
+	dbus_g_proxy_begin_call_with_timeout (priv->context_proxy,
+	                                      "SetProperty", stage1_prepare_done,
+	                                      self, NULL, 40000,
+	                                      G_TYPE_STRING, "Active",
+	                                      G_TYPE_VALUE, &value,
+	                                      G_TYPE_INVALID);
+
+}
+
+static void
+context_set_property (gpointer key, gpointer value, gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	GValue val = G_VALUE_INIT;
+
+	nm_log_dbg (LOGD_MB, "%s -- setting context prop: %s == %s",
+	            __func__,
+	            (char*)key,
+	            (char*)value);
+
+	g_value_init (&val, G_TYPE_STRING);
+	g_value_set_string (&val, (char*)value);
+
+	if (!priv->property_error) {
+		dbus_g_proxy_call_with_timeout (priv->context_proxy,
+		                                "SetProperty",
+		                                20000,
+		                                &priv->property_error,
+		                                G_TYPE_STRING, (char*)key,
+		                                G_TYPE_VALUE, &val,
+		                                G_TYPE_INVALID);
+	} else {
+		nm_log_warn (LOGD_MB, "could not set context property '%s': %s", (char*)key,
+		             priv->property_error
+		             && priv->property_error->message
+		             ? priv->property_error->message : "(unknown)");
+	}
+}
+
+static void stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data);
+
+static void
+stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (user_data);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	GError *error = NULL;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
+		if (priv->context_path)
+			do_context_activate (self, priv->context_path);
+		else
+			g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED);
+	} else {
+		nm_log_warn (LOGD_MB, "OFONO modem enable failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED);
+
+		g_error_free (error);
+	}
+}
+
+static GHashTable *
+create_connect_properties (NMConnection *connection)
+{
+	NMSettingGsm *setting;
+	GHashTable *properties;
+	const char *str;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	setting = nm_connection_get_setting_gsm (connection);
+	properties = g_hash_table_new (g_str_hash, g_str_equal);
+
+	str = nm_setting_gsm_get_apn (setting);
+	if (str)
+		g_hash_table_insert (properties, "AccessPointName", g_strdup (str));
+
+	str = nm_setting_gsm_get_username (setting);
+	if (str)
+		g_hash_table_insert (properties, "Username", g_strdup (str));
+
+	str = nm_setting_gsm_get_password (setting);
+	if (str)
+		g_hash_table_insert (properties, "Password", g_strdup (str));
+
+	return properties;
+}
+
+static NMActStageReturn
+act_stage1_prepare (NMModem *modem,
+                    NMConnection *connection,
+                    NMDeviceStateReason *reason)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (modem);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	const char *context_id;
+	char *context_path;
+	char **id = NULL;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	context_id = nm_connection_get_id (connection);
+	id = g_strsplit (context_id, "/", 0);
+	g_assert (id[2]);
+
+	nm_log_dbg (LOGD_MB, " trying %s %s", id[1], id[2]);
+
+	if (priv->context_path)
+		g_free (priv->context_path);
+
+	priv->context_path = g_strdup_printf ("%s/%s",
+	                                      nm_modem_get_path (modem),
+	                                      id[2]);
+	g_strfreev (id);
+
+	if (!priv->context_path) {
+		*reason = NM_DEVICE_STATE_REASON_GSM_APN_FAILED;
+		return NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	if (priv->connect_properties)
+		g_hash_table_destroy (priv->connect_properties);
+	priv->connect_properties = create_connect_properties (connection);
+
+	nm_log_info (LOGD_MB, "(%s): activating context %s",
+	             nm_modem_get_path (modem),
+	             priv->context_path);
+
+	if (nm_modem_get_state (modem) == NM_MODEM_STATE_REGISTERED) {
+		do_context_activate (self, priv->context_path);
+	} else {
+		nm_log_warn (LOGD_MB, "(%s): could not activate context, "
+		             "modem is not registered.",
+		             nm_modem_get_path (modem));
+		*reason = NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER;
+		return NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	return NM_ACT_STAGE_RETURN_POSTPONE;
+}
+
+static NMActStageReturn
+static_stage3_ip4_config_start (NMModem *_self,
+                                NMActRequest *req,
+                                NMDeviceStateReason *reason)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (_self);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_FAILURE;
+	GError *error = NULL;
+
+	if (priv->ip4_config) {
+		g_signal_emit_by_name (self, NM_MODEM_IP4_CONFIG_RESULT, priv->ip4_config, error);
+		priv->ip4_config = NULL;
+		nm_modem_set_state (NM_MODEM (self),
+		                    NM_MODEM_STATE_CONNECTED,
+		                    nm_modem_state_to_string (NM_MODEM_STATE_CONNECTED));
+		ret = NM_ACT_STAGE_RETURN_POSTPONE;
+	}
+
+	return ret;
+}
+
+static gboolean
+check_connection_compatible (NMModem *modem,
+                             NMConnection *connection)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (modem);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+	NMSettingConnection *s_con;
+	NMSettingGsm *s_gsm;
+	GHashTable *properties;
+	GError *error = NULL;
+	const char *uuid;
+	const char *id;
+	const char *imsi;
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	uuid = nm_connection_get_uuid (connection);
+
+	if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_GSM_SETTING_NAME)) {
+		nm_log_dbg (LOGD_MB, "%s isn't of the right type, skipping.", uuid);
+		return FALSE;
+	}
+
+	s_gsm = nm_connection_get_setting_gsm (connection);
+	if (!s_gsm)
+		return FALSE;
+
+	id = nm_connection_get_id (connection);
+	if (!g_strrstr (id, "/context")) {
+		nm_log_dbg (LOGD_MB, "%s (%s) isn't of the right type, skipping.", id, uuid);
+		return FALSE;
+	}
+
+	dbus_g_proxy_call_with_timeout (priv->simmanager_proxy,
+	                                "GetProperties",
+	                                20000,
+	                                &error,
+	                                G_TYPE_INVALID,
+	                                DBUS_TYPE_G_MAP_OF_VARIANT, &properties,
+	                                G_TYPE_INVALID);
+
+	if (error) {
+		nm_log_warn (LOGD_MB, "Could not get SIM properties to match connections: %s",
+		             error && error->message ? error->message : "(unknown)");
+		g_clear_error (&error);
+	}
+
+	imsi = g_value_get_string (g_hash_table_lookup (properties, "SubscriberIdentity"));
+	if (! g_strrstr (id, imsi)) {
+		nm_log_dbg (LOGD_MB, "%s (%s) isn't for the right SIM, skipping.", id, uuid);
+		return FALSE;
+	}
+
+	nm_log_dbg (LOGD_MB, "%s (%s) looks compatible with IMSI %s", id, uuid, imsi);
+
+	return TRUE;
+}
+
+static void
+get_ofono_properties_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	NMModem *self = NM_MODEM (user_data);
+	GError *error = NULL;
+	GHashTable *properties = NULL;
+	GValue *value = NULL;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	if (!dbus_g_proxy_end_call (proxy, call_id, &error,
+	                            DBUS_TYPE_G_MAP_OF_VARIANT, &properties,
+	                            G_TYPE_INVALID)) {
+		nm_log_warn (LOGD_MB, "failed get modem enabled state: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+		return;
+	}
+
+	value = g_hash_table_lookup (properties, "Online");
+	if (value)
+		ofono_properties_changed (NULL, "Online", value, self);
+	else
+		nm_log_warn (LOGD_MB, "failed get modem online state: unexpected reply type");
+	g_value_unset (value);
+
+	value = g_hash_table_lookup (properties, "Interfaces");
+	if (value)
+		ofono_properties_changed (NULL, "Interfaces", value, self);
+	else
+		nm_log_warn (LOGD_MB, "failed get available oFono interfaces: unexpected reply type");
+	g_value_unset (value);
+}
+
+static void
+query_ofono_properties (NMModemOfono *self)
+{
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+	dbus_g_proxy_begin_call (NM_MODEM_OFONO_GET_PRIVATE (self)->modem_proxy,
+	                         "GetProperties", get_ofono_properties_done,
+	                         self, NULL,
+	                         G_TYPE_INVALID);
+}
+
+static void
+set_ofono_enabled (NMModem *self, gboolean enabled)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+
+	nm_log_info (LOGD_MB, "(%s): trying to set modem to %s",
+	             nm_modem_get_path (self),
+	             enabled ? "enabled" : "disabled");
+
+	/*
+	 * FIXME: this is code is a no-op; we should either make
+	 * work, or get rid of this function, or at least remove
+	 * the call to update_ofono_enabled.
+	 */
+
+	update_ofono_enabled (NM_MODEM_OFONO (self),
+	                      priv->modem_online
+	                      && priv->gprs_powered
+	                      && priv->gprs_attached);
+}
+
+static void
+get_capabilities (NMModem *_self,
+                  NMDeviceModemCapabilities *modem_caps,
+                  NMDeviceModemCapabilities *current_caps)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (_self);
+	NMDeviceModemCapabilities all_ofono_caps = NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS;
+
+	*modem_caps = all_ofono_caps;
+	*current_caps = all_ofono_caps;
+}
+
+static void
+nm_modem_ofono_init (NMModemOfono *self)
+{
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	priv->dbus_mgr = nm_dbus_manager_get ();
+
+	priv->modem_proxy = NULL;
+	priv->connman_proxy = NULL;
+	priv->context_proxy = NULL;
+	priv->simmanager_proxy = NULL;
+
+	priv->modem_online = FALSE;
+	priv->gprs_powered = FALSE;
+	priv->gprs_attached = FALSE;
+
+	priv->ip4_config = NULL;
+}
+
+static GObject*
+constructor (GType type,
+             guint n_construct_params,
+             GObjectConstructParam *construct_params)
+{
+	GObject *object;
+	NMModemOfonoPrivate *priv;
+	DBusGConnection *bus;
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	object = G_OBJECT_CLASS (nm_modem_ofono_parent_class)->constructor (type, n_construct_params, construct_params);
+	if (!object)
+		return NULL;
+
+	priv = NM_MODEM_OFONO_GET_PRIVATE (object);
+	bus = nm_dbus_manager_get_connection (priv->dbus_mgr);
+	priv->modem_proxy = get_ofono_proxy (NM_MODEM_OFONO (object),
+	                                     nm_modem_get_path (NM_MODEM (object)),
+	                                     OFONO_DBUS_INTERFACE_MODEM);
+
+	dbus_g_object_register_marshaller (g_cclosure_marshal_generic,
+	                                   G_TYPE_NONE,
+	                                   G_TYPE_STRING, G_TYPE_VALUE,
+	                                   G_TYPE_INVALID);
+	dbus_g_proxy_add_signal (priv->modem_proxy, "PropertyChanged",
+	                         G_TYPE_STRING, G_TYPE_VALUE,
+	                         G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (priv->modem_proxy, "PropertyChanged",
+	                             G_CALLBACK (ofono_properties_changed),
+	                             object,
+	                             NULL);
+
+	query_ofono_properties (NM_MODEM_OFONO (object));
+
+	return object;
+}
+
+static void
+dispose (GObject *object)
+{
+	NMModemOfono *self = NM_MODEM_OFONO (object);
+	NMModemOfonoPrivate *priv = NM_MODEM_OFONO_GET_PRIVATE (self);
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	if (priv->connect_properties)
+		g_hash_table_destroy (priv->connect_properties);
+
+	if (priv->ip4_config)
+		g_object_unref (priv->ip4_config);
+
+	if (priv->modem_proxy)
+		g_object_unref (priv->modem_proxy);
+	if (priv->connman_proxy)
+		g_object_unref (priv->connman_proxy);
+	if (priv->context_proxy)
+		g_object_unref (priv->context_proxy);
+
+	G_OBJECT_CLASS (nm_modem_ofono_parent_class)->dispose (object);
+}
+
+static void
+nm_modem_ofono_class_init (NMModemOfonoClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	NMModemClass *modem_class = NM_MODEM_CLASS (klass);
+
+	nm_log_dbg (LOGD_MB, "in %s", __func__);
+
+	g_type_class_add_private (object_class, sizeof (NMModemOfonoPrivate));
+
+	/* Virtual methods */
+	object_class->constructor = constructor;
+	object_class->dispose = dispose;
+
+	modem_class->get_capabilities = get_capabilities;
+	modem_class->set_mm_enabled = set_ofono_enabled;
+	modem_class->disconnect = disconnect;
+	modem_class->deactivate = deactivate;
+	modem_class->check_connection_compatible = check_connection_compatible;
+	modem_class->act_stage1_prepare = act_stage1_prepare;
+	modem_class->static_stage3_ip4_config_start = static_stage3_ip4_config_start;
+}
+
Index: network-manager-0.9.10.0/src/devices/wwan/nm-modem-ofono.h
===================================================================
--- /dev/null
+++ network-manager-0.9.10.0/src/devices/wwan/nm-modem-ofono.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2013 - Canonical Ltd.
+ */
+
+#ifndef NM_MODEM_OFONO_H
+#define NM_MODEM_OFONO_H
+
+#include <nm-modem.h>
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_MODEM_OFONO            (nm_modem_ofono_get_type ())
+#define NM_MODEM_OFONO(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_MODEM_OFONO, NMModemOfono))
+#define NM_IS_MODEM_OFONO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_MODEM_OFONO))
+#define NM_MODEM_OFONO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  NM_TYPE_MODEM_OFONO, NMModemOfonoClass))
+#define NM_IS_MODEM_OFONO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  NM_TYPE_MODEM_OFONO))
+#define NM_MODEM_OFONO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  NM_TYPE_MODEM_OFONO, NMModemOfonoClass))
+#define NM_MODEM_OFONO_MODEM "modem"
+
+#define OFONO_DBUS_SERVICE                      "org.ofono"
+#define OFONO_DBUS_PATH                         "/"
+#define OFONO_DBUS_INTERFACE                    "org.ofono.Manager"
+#define OFONO_DBUS_INTERFACE_MODEM              "org.ofono.Modem"
+#define OFONO_DBUS_INTERFACE_CONNECTION_MANAGER "org.ofono.ConnectionManager"
+#define OFONO_DBUS_INTERFACE_CONNECTION_CONTEXT "org.ofono.ConnectionContext"
+#define OFONO_DBUS_INTERFACE_SIM_MANAGER        "org.ofono.SimManager"
+
+typedef enum {
+        NM_OFONO_ERROR_CONNECTION_NOT_OFONO = 0,  /*< nick=ConnectionNotOfono >*/
+        NM_OFONO_ERROR_CONNECTION_INVALID,      /*< nick=ConnectionInvalid >*/
+        NM_OFONO_ERROR_CONNECTION_INCOMPATIBLE, /*< nick=ConnectionIncompatible >*/
+} NMOfonoError;
+
+typedef struct {
+	NMModem parent;
+} NMModemOfono;
+
+typedef struct {
+	NMModemClass parent;
+} NMModemOfonoClass;
+
+GType nm_modem_ofono_get_type (void);
+
+NMModem *nm_modem_ofono_new (const char *path);
+
+G_END_DECLS
+
+#endif /* NM_MODEM_OFONO_H */
Index: network-manager-0.9.10.0/src/NetworkManagerUtils.c
===================================================================
--- network-manager-0.9.10.0.orig/src/NetworkManagerUtils.c
+++ network-manager-0.9.10.0/src/NetworkManagerUtils.c
@@ -1221,7 +1221,13 @@ nm_utils_ip6_property_path (const char *
 
 	len = g_snprintf (path, sizeof (path), IPV6_PROPERTY_DIR "%s/%s",
 	                  ifname, property);
-	g_assert (len < sizeof (path) - 1);
+
+	/* Ubuntu: don't assert, but log about the inconsistent size. */
+	if (len > sizeof (path) - 1)
+		nm_log_warn (LOGD_CORE,
+		             "IPv6 property path is too long: '"
+		             IPV6_PROPERTY_DIR "%s/%s'",
+	                     ifname, property);
 
 	return path;
 }
@@ -1252,6 +1258,14 @@ fail:
 		nm_log_err (LOGD_CORE, "Failed asserting path component: NULL");
 	else
 		nm_log_err (LOGD_CORE, "Failed asserting path component: \"%s\"", name);
-	g_error ("FATAL: Failed asserting path component: %s", name ? name : "(null)");
+
+	/* Ubuntu: Don't outright fail, just return the name again. It's
+	 * logged as being invalid, which is enough.
+	 * There is a use of slashes in paths for oFono modems, which are
+	 * actually valid paths to refer to an oFono modem, just don't map to
+	 * anything on the filesystem. The following calls to sysctl paths can
+	 * (and will) fail, but that's fine.
+	 */
+	return name;
 }
 
Index: network-manager-0.9.10.0/src/devices/wwan/nm-device-modem.c
===================================================================
--- network-manager-0.9.10.0.orig/src/devices/wwan/nm-device-modem.c
+++ network-manager-0.9.10.0/src/devices/wwan/nm-device-modem.c
@@ -201,6 +201,16 @@ modem_state_cb (NMModem *modem,
 		}
 	}
 
+	if (dev_state >= NM_DEVICE_STATE_DISCONNECTED &&
+	    new_state == NM_MODEM_STATE_REGISTERED && old_state < NM_MODEM_STATE_REGISTERED) {
+
+		nm_log_info (LOGD_MB, "(%s): modem re-registered; re-checking autoconnect",
+		             nm_device_get_iface (device));
+
+		g_object_set (G_OBJECT (device), NM_DEVICE_AUTOCONNECT, TRUE, NULL);
+		nm_device_emit_recheck_auto_activate (device);
+	}
+
 	if (new_state < NM_MODEM_STATE_CONNECTING &&
 	    old_state >= NM_MODEM_STATE_CONNECTING &&
 	    dev_state >= NM_DEVICE_STATE_NEED_AUTH &&
@@ -271,6 +281,14 @@ device_state_changed (NMDevice *device,
 		             nm_modem_state_to_string (nm_modem_get_state (priv->modem)));
 	}
 
+	/* Block autoconnect until the modem is registered again */
+	if (new_state == NM_DEVICE_STATE_FAILED && nm_modem_get_state (priv->modem) == NM_MODEM_STATE_SEARCHING) {
+		nm_log_info (LOGD_MB, "(%s): modem searching; disabling autoconnect",
+		             nm_device_get_iface (device));
+
+		g_object_set (G_OBJECT (device), NM_DEVICE_AUTOCONNECT, FALSE, NULL);
+	}
+
 	nm_modem_device_state_changed (priv->modem, new_state, old_state, reason);
 
 	switch (reason) {
