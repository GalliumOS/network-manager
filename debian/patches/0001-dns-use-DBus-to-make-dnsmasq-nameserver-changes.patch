From 4519b226df05cc2ae1779ca2f2314109b6a33d84 Mon Sep 17 00:00:00 2001
From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Date: Tue, 11 Nov 2014 11:09:18 -0500
Subject: [PATCH] dns: use DBus to make dnsmasq nameserver changes

Use DBus to make nameserver updates rather than restarting the dnsmasq binary
again and again.

Signed-off-by: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
---
 src/dns-manager/nm-dns-dnsmasq.c        |  344 +++++++++++++++++++++++---------
 src/dns-manager/nm-dns-manager.c        |   19 +
 src/dns-manager/nm-dns-plugin.c         |   18 +
 src/dns-manager/nm-dns-plugin.h         |    1 
 src/org.freedesktop.NetworkManager.conf |   10 
 5 files changed, 304 insertions(+), 88 deletions(-)

Index: b/src/dns-manager/nm-dns-dnsmasq.c
===================================================================
--- a/src/dns-manager/nm-dns-dnsmasq.c
+++ b/src/dns-manager/nm-dns-dnsmasq.c
@@ -32,6 +32,7 @@
 #include "nm-ip4-config.h"
 #include "nm-ip6-config.h"
 #include "nm-dns-utils.h"
+#include "nm-bus-manager.h"
 #include "NetworkManagerUtils.h"
 
 G_DEFINE_TYPE (NMDnsDnsmasq, nm_dns_dnsmasq, NM_TYPE_DNS_PLUGIN)
@@ -39,11 +40,17 @@ G_DEFINE_TYPE (NMDnsDnsmasq, nm_dns_dnsm
 #define NM_DNS_DNSMASQ_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DNS_DNSMASQ, NMDnsDnsmasqPrivate))
 
 #define PIDFILE NMRUNDIR "/dnsmasq.pid"
-#define CONFFILE NMRUNDIR "/dnsmasq.conf"
 #define CONFDIR NMCONFDIR "/dnsmasq.d"
 
+#define DNSMASQ_DBUS_SERVICE "org.freedesktop.NetworkManager.dnsmasq"
+#define DNSMASQ_DBUS_PATH "/uk/org/thekelleys/dnsmasq"
+
 typedef struct {
-	guint32 foo;
+	GDBusProxy *dnsmasq;
+	GCancellable *dnsmasq_cancellable;
+	gboolean running;
+
+	GVariant *set_servers_ex_args;
 } NMDnsDnsmasqPrivate;
 
 /*****************************************************************************/
@@ -61,8 +68,28 @@ typedef struct {
 
 /*****************************************************************************/
 
+static void
+add_dnsmasq_nameserver (NMDnsDnsmasq *self,
+                        GVariantBuilder *servers,
+                        const char *ip,
+                        const char *domain)
+{
+	g_return_if_fail (ip);
+
+	_LOGD ("adding nameserver '%s' for domain '%s'",
+	       ip, domain);
+
+	g_variant_builder_open (servers, G_VARIANT_TYPE ("as"));
+
+	g_variant_builder_add (servers, "s", ip);
+	if (domain)
+		g_variant_builder_add (servers, "s", domain);
+
+	g_variant_builder_close (servers);
+}
+
 static gboolean
-add_ip4_config (GString *str, NMIP4Config *ip4, gboolean split)
+add_ip4_config (NMDnsDnsmasq *self, GVariantBuilder *servers, NMIP4Config *ip4, gboolean split)
 {
 	char buf[INET_ADDRSTRLEN];
 	in_addr_t addr;
@@ -84,9 +111,10 @@ add_ip4_config (GString *str, NMIP4Confi
 			/* searches are preferred over domains */
 			n = nm_ip4_config_get_num_searches (ip4);
 			for (i = 0; i < n; i++) {
-				g_string_append_printf (str, "server=/%s/%s\n",
-				                        nm_ip4_config_get_search (ip4, i),
-				                        buf);
+				add_dnsmasq_nameserver (self,
+				                        servers,
+				                        buf,
+				                        nm_ip4_config_get_search (ip4, i));
 				added = TRUE;
 			}
 
@@ -94,9 +122,10 @@ add_ip4_config (GString *str, NMIP4Confi
 				/* If not searches, use any domains */
 				n = nm_ip4_config_get_num_domains (ip4);
 				for (i = 0; i < n; i++) {
-					g_string_append_printf (str, "server=/%s/%s\n",
-					                        nm_ip4_config_get_domain (ip4, i),
-					                        buf);
+					add_dnsmasq_nameserver (self,
+					                        servers,
+					                        buf,
+					                        nm_ip4_config_get_domain (ip4, i));
 					added = TRUE;
 				}
 			}
@@ -107,7 +136,7 @@ add_ip4_config (GString *str, NMIP4Confi
 			domains = nm_dns_utils_get_ip4_rdns_domains (ip4);
 			if (domains) {
 				for (iter = domains; iter && *iter; iter++)
-					g_string_append_printf (str, "server=/%s/%s\n", *iter, buf);
+					add_dnsmasq_nameserver (self, servers, buf, *iter);
 				g_strfreev (domains);
 				added = TRUE;
 			}
@@ -118,7 +147,8 @@ add_ip4_config (GString *str, NMIP4Confi
 	if (!added) {
 		for (i = 0; i < nnameservers; i++) {
 			addr = nm_ip4_config_get_nameserver (ip4, i);
-			g_string_append_printf (str, "server=%s\n", nm_utils_inet4_ntop (addr, NULL));
+			add_dnsmasq_nameserver (self, servers,
+			                        nm_utils_inet4_ntop (addr, NULL), NULL);
 		}
 	}
 
@@ -148,7 +178,7 @@ ip6_addr_to_string (const struct in6_add
 }
 
 static void
-add_global_config (GString *str, const NMGlobalDnsConfig *config)
+add_global_config (NMDnsDnsmasq *self, GVariantBuilder *dnsmasq_servers, const NMGlobalDnsConfig *config)
 {
 	guint i, j;
 
@@ -163,16 +193,16 @@ add_global_config (GString *str, const N
 
 		for (j = 0; servers && servers[j]; j++) {
 			if (!strcmp (name, "*"))
-				g_string_append_printf (str, "server=%s\n", servers[j]);
+				add_dnsmasq_nameserver (self, dnsmasq_servers, servers[j], NULL);
 			else
-				g_string_append_printf (str, "server=/%s/%s\n", name, servers[j]);
+				add_dnsmasq_nameserver (self, dnsmasq_servers, servers[j], name);
 		}
 
 	}
 }
 
 static gboolean
-add_ip6_config (GString *str, NMIP6Config *ip6, gboolean split)
+add_ip6_config (NMDnsDnsmasq *self, GVariantBuilder *servers, NMIP6Config *ip6, gboolean split)
 {
 	const struct in6_addr *addr;
 	char *buf = NULL;
@@ -196,9 +226,10 @@ add_ip6_config (GString *str, NMIP6Confi
 			/* searches are preferred over domains */
 			n = nm_ip6_config_get_num_searches (ip6);
 			for (i = 0; i < n; i++) {
-				g_string_append_printf (str, "server=/%s/%s\n",
-				                        nm_ip6_config_get_search (ip6, i),
-				                        buf);
+				add_dnsmasq_nameserver (self,
+				                        servers,
+				                        buf,
+				                        nm_ip6_config_get_search (ip6, i));
 				added = TRUE;
 			}
 
@@ -206,9 +237,10 @@ add_ip6_config (GString *str, NMIP6Confi
 				/* If not searches, use any domains */
 				n = nm_ip6_config_get_num_domains (ip6);
 				for (i = 0; i < n; i++) {
-					g_string_append_printf (str, "server=/%s/%s\n",
-					                        nm_ip6_config_get_domain (ip6, i),
-					                        buf);
+					add_dnsmasq_nameserver (self,
+					                        servers,
+					                        buf,
+					                        nm_ip6_config_get_domain (ip6, i));
 					added = TRUE;
 				}
 			}
@@ -223,7 +255,7 @@ add_ip6_config (GString *str, NMIP6Confi
 			addr = nm_ip6_config_get_nameserver (ip6, i);
 			buf = ip6_addr_to_string (addr, iface);
 			if (buf) {
-				g_string_append_printf (str, "server=%s\n", buf);
+				add_dnsmasq_nameserver (self, servers, buf, NULL);
 				g_free (buf);
 			}
 		}
@@ -232,6 +264,176 @@ add_ip6_config (GString *str, NMIP6Confi
 	return TRUE;
 }
 
+static void
+dnsmasq_update_done (GObject *source, GAsyncResult *res, gpointer user_data)
+{
+	NMDnsDnsmasq *self = NM_DNS_DNSMASQ (user_data);
+	NMDnsDnsmasqPrivate *priv = NM_DNS_DNSMASQ_GET_PRIVATE (self);
+	gs_free_error GError *error = NULL;
+	gs_unref_variant GVariant *response;
+
+	response = g_dbus_proxy_call_finish (priv->dnsmasq, res, &error);
+	if (!response)
+		_LOGW ("dnsmasq update failed: %s", error->message);
+}
+
+static gboolean
+send_dnsmasq_update (NMDnsDnsmasq *self)
+{
+	NMDnsDnsmasqPrivate *priv = NM_DNS_DNSMASQ_GET_PRIVATE (self);
+
+	g_return_val_if_fail (priv->set_servers_ex_args, FALSE);
+
+	if (priv->running) {
+		_LOGD ("trying to update dnsmasq nameservers");
+
+		g_dbus_proxy_call (priv->dnsmasq,
+		                   "SetServersEx",
+		                   priv->set_servers_ex_args,
+		                   G_DBUS_CALL_FLAGS_NONE,
+		                   -1,
+		                   NULL,
+		                   (GAsyncReadyCallback) dnsmasq_update_done,
+		                   self);
+		g_clear_pointer (&priv->set_servers_ex_args, g_variant_unref);
+	} else
+		_LOGW ("dnsmasq not found on the bus. The nameserver update will be sent when dnsmasq appears");
+
+	return TRUE;
+}
+
+static void
+name_owner_changed (GObject    *object,
+                    GParamSpec *pspec,
+                    gpointer    user_data)
+{
+	NMDnsDnsmasq *self = NM_DNS_DNSMASQ (user_data);
+	NMDnsDnsmasqPrivate *priv = NM_DNS_DNSMASQ_GET_PRIVATE (self);
+	gs_free char *owner = NULL;
+
+	owner = g_dbus_proxy_get_name_owner (G_DBUS_PROXY (object));
+	if (owner) {
+		_LOGI ("dnsmasq appeared as %s", owner);
+		priv->running = TRUE;
+		g_signal_emit_by_name (self, NM_DNS_PLUGIN_APPEARED);
+	} else {
+		_LOGI ("dnsmasq disappeared");
+		priv->running = FALSE;
+		g_signal_emit_by_name (self, NM_DNS_PLUGIN_FAILED);
+	}
+}
+
+static void
+dnsmasq_proxy_cb (GObject *source, GAsyncResult *res, gpointer user_data)
+{
+	NMDnsDnsmasq *self;
+	NMDnsDnsmasqPrivate *priv;
+	gs_free_error GError *error = NULL;
+	gs_free char *owner = NULL;
+	GDBusProxy *proxy;
+
+	proxy = g_dbus_proxy_new_finish (res, &error);
+	if (   !proxy
+	    && g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+		return;
+
+	self = NM_DNS_DNSMASQ (user_data);
+
+	if (!proxy) {
+		_LOGW ("failed to connect to dnsmasq via DBus: %s", error->message);
+		g_signal_emit_by_name (self, NM_DNS_PLUGIN_FAILED);
+		return;
+	}
+
+	priv = NM_DNS_DNSMASQ_GET_PRIVATE (self);
+
+	priv->dnsmasq = proxy;
+	nm_clear_g_cancellable (&priv->dnsmasq_cancellable);
+
+	_LOGD ("dnsmasq proxy creation successful");
+
+	g_signal_connect (priv->dnsmasq, "notify::g-name-owner",
+			  G_CALLBACK (name_owner_changed), self);
+	owner = g_dbus_proxy_get_name_owner (priv->dnsmasq);
+	priv->running = (owner != NULL);
+
+	if (priv->running && priv->set_servers_ex_args)
+		send_dnsmasq_update (self);
+}
+
+static gboolean
+start_dnsmasq (NMDnsDnsmasq *self)
+{
+	NMDnsDnsmasqPrivate *priv = NM_DNS_DNSMASQ_GET_PRIVATE (self);
+ 	const char *dm_binary;
+ 	const char *argv[15];
+ 	GPid pid = 0;
+ 	guint idx = 0;
+
+	/* dnsmasq is probably already started; if it's the case, don't do
+	 * anything more.
+	 */
+	if (priv->running) {
+		_LOGD ("dnsmasq is already running");
+		return TRUE;
+	}
+
+	/* Start dnsmasq */
+
+ 	dm_binary = nm_utils_find_helper ("dnsmasq", DNSMASQ_PATH, NULL);
+ 	if (!dm_binary) {
+		_LOGW ("could not find dnsmasq binary");
+ 		return FALSE;
+ 	}
+
+	argv[idx++] = dm_binary;
+	argv[idx++] = "--no-resolv";  /* Use only commandline */
+	argv[idx++] = "--keep-in-foreground";
+	argv[idx++] = "--no-hosts"; /* don't use /etc/hosts to resolve */
+	argv[idx++] = "--bind-interfaces";
+	argv[idx++] = "--pid-file=" PIDFILE;
+	argv[idx++] = "--listen-address=127.0.0.1"; /* Should work for both 4 and 6 */
+	argv[idx++] = "--cache-size=400";
+	argv[idx++] = "--proxy-dnssec"; /* Allow DNSSEC to pass through */
+	argv[idx++] = "--enable-dbus=" DNSMASQ_DBUS_SERVICE;
+
+	/* dnsmasq exits if the conf dir is not present */
+	if (g_file_test (CONFDIR, G_FILE_TEST_IS_DIR))
+		argv[idx++] = "--conf-dir=" CONFDIR;
+
+	argv[idx++] = NULL;
+	nm_assert (idx <= G_N_ELEMENTS (argv));
+
+	/* And finally spawn dnsmasq */
+	pid = nm_dns_plugin_child_spawn (NM_DNS_PLUGIN (self), argv, PIDFILE, "bin/dnsmasq");
+	if (!pid)
+		return FALSE;
+
+	if (!priv->dnsmasq && !priv->dnsmasq_cancellable) {
+		NMBusManager *dbus_mgr;
+		GDBusConnection *connection;
+
+		dbus_mgr = nm_bus_manager_get ();
+		g_return_val_if_fail (dbus_mgr, FALSE);
+
+		connection = nm_bus_manager_get_connection (dbus_mgr);
+		g_return_val_if_fail (connection, FALSE);
+
+		priv->dnsmasq_cancellable = g_cancellable_new ();
+		g_dbus_proxy_new (connection,
+		                  G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START,
+		                  NULL,
+		                  DNSMASQ_DBUS_SERVICE,
+		                  DNSMASQ_DBUS_PATH,
+		                  DNSMASQ_DBUS_SERVICE,
+		                  priv->dnsmasq_cancellable,
+		                  dnsmasq_proxy_cb,
+		                  self);
+	}
+
+	return TRUE;
+}
+
 static gboolean
 update (NMDnsPlugin *plugin,
         const GSList *vpn_configs,
@@ -241,96 +443,59 @@ update (NMDnsPlugin *plugin,
         const char *hostname)
 {
 	NMDnsDnsmasq *self = NM_DNS_DNSMASQ (plugin);
-	const char *dm_binary;
-	GString *conf;
+	NMDnsDnsmasqPrivate *priv = NM_DNS_DNSMASQ_GET_PRIVATE (self);
 	GSList *iter;
-	const char *argv[15];
-	GError *error = NULL;
-	int ignored;
-	GPid pid = 0;
-	guint idx = 0;
-
-	/* Kill the old dnsmasq; there doesn't appear to be a way to get dnsmasq
-	 * to reread the config file using SIGHUP or similar.  This is a small race
-	 * here when restarting dnsmasq when DNS requests could go to the upstream
-	 * servers instead of to dnsmasq.
-	 */
-	nm_dns_plugin_child_kill (plugin);
+	gboolean ret = FALSE;
+	GVariantBuilder servers;
 
-	dm_binary = nm_utils_find_helper ("dnsmasq", DNSMASQ_PATH, NULL);
-	if (!dm_binary) {
-		_LOGW ("could not find dnsmasq binary");
-		return FALSE;
-	}
+	if (!priv->running)
+		start_dnsmasq (self);
 
-	/* Build up the new dnsmasq config file */
-	conf = g_string_sized_new (150);
+	g_variant_builder_init (&servers, G_VARIANT_TYPE ("aas"));
 
+	/* Build up the new dnsmasq config file */
 	if (global_config)
-		add_global_config (conf, global_config);
+		add_global_config (self, &servers, global_config);
 	else {
 		/* Use split DNS for VPN configs */
 		for (iter = (GSList *) vpn_configs; iter; iter = g_slist_next (iter)) {
 			if (NM_IS_IP4_CONFIG (iter->data))
-				add_ip4_config (conf, NM_IP4_CONFIG (iter->data), TRUE);
+				add_ip4_config (self, &servers, iter->data, TRUE);
 			else if (NM_IS_IP6_CONFIG (iter->data))
-				add_ip6_config (conf, NM_IP6_CONFIG (iter->data), TRUE);
+				add_ip6_config (self, &servers, iter->data, TRUE);
 		}
 
 		/* Now add interface configs without split DNS */
 		for (iter = (GSList *) dev_configs; iter; iter = g_slist_next (iter)) {
 			if (NM_IS_IP4_CONFIG (iter->data))
-				add_ip4_config (conf, NM_IP4_CONFIG (iter->data), FALSE);
+				add_ip4_config (self, &servers, iter->data, FALSE);
 			else if (NM_IS_IP6_CONFIG (iter->data))
-				add_ip6_config (conf, NM_IP6_CONFIG (iter->data), FALSE);
+				add_ip6_config (self, &servers, iter->data, FALSE);
 		}
 
 		/* And any other random configs */
 		for (iter = (GSList *) other_configs; iter; iter = g_slist_next (iter)) {
 			if (NM_IS_IP4_CONFIG (iter->data))
-				add_ip4_config (conf, NM_IP4_CONFIG (iter->data), FALSE);
+				add_ip4_config (self, &servers, iter->data, FALSE);
 			else if (NM_IS_IP6_CONFIG (iter->data))
-				add_ip6_config (conf, NM_IP6_CONFIG (iter->data), FALSE);
+				add_ip6_config (self, &servers, iter->data, FALSE);
 		}
 	}
+	g_clear_pointer (&priv->set_servers_ex_args, g_variant_unref);
+	priv->set_servers_ex_args = g_variant_ref_sink (g_variant_new ("(aas)", &servers));
 
-	/* Write out the config file */
-	if (!g_file_set_contents (CONFFILE, conf->str, -1, &error)) {
-		_LOGW ("failed to write dnsmasq config file %s: %s",
-		       CONFFILE,
-		       error->message);
-		g_clear_error (&error);
-		goto out;
-	}
-	ignored = chmod (CONFFILE, 0644);
-
-	_LOGD ("dnsmasq local caching DNS configuration:");
-	_LOGD ("%s", conf->str);
-
-	argv[idx++] = dm_binary;
-	argv[idx++] = "--no-resolv";  /* Use only commandline */
-	argv[idx++] = "--keep-in-foreground";
-	argv[idx++] = "--no-hosts"; /* don't use /etc/hosts to resolve */
-	argv[idx++] = "--bind-interfaces";
-	argv[idx++] = "--pid-file=" PIDFILE;
-	argv[idx++] = "--listen-address=127.0.0.1"; /* Should work for both 4 and 6 */
-	argv[idx++] = "--conf-file=" CONFFILE;
-	argv[idx++] = "--cache-size=400";
-	argv[idx++] = "--proxy-dnssec"; /* Allow DNSSEC to pass through */
-
-	/* dnsmasq exits if the conf dir is not present */
-	if (g_file_test (CONFDIR, G_FILE_TEST_IS_DIR))
-		argv[idx++] = "--conf-dir=" CONFDIR;
-
-	argv[idx++] = NULL;
-	g_warn_if_fail (idx <= G_N_ELEMENTS (argv));
+	ret = send_dnsmasq_update (self);
 
-	/* And finally spawn dnsmasq */
-	pid = nm_dns_plugin_child_spawn (NM_DNS_PLUGIN (self), argv, PIDFILE, "bin/dnsmasq");
+	/* If all the configs lists are empty, there is just nothing to be caching --
+	 * we cleared up the dnsmasq cache; but we should also fail the update, so
+	 * that we don't write 127.0.0.1 to resolv.conf.
+	 */
+	if (((vpn_configs && g_slist_length ((GSList *) vpn_configs) < 1) || !vpn_configs) &&
+	    ((dev_configs && g_slist_length ((GSList *) dev_configs) < 1) || !dev_configs) &&
+	    ((other_configs && g_slist_length ((GSList *) other_configs) < 1) || !other_configs))
+		ret = FALSE;
 
-out:
-	g_string_free (conf, TRUE);
-	return pid ? TRUE : FALSE;
+	return ret;
 }
 
 /****************************************************************/
@@ -374,7 +539,6 @@ child_quit (NMDnsPlugin *plugin, gint st
 		_LOGW ("dnsmasq died with signal %d", WTERMSIG (status));
 	else
 		_LOGW ("dnsmasq died from an unknown cause");
-	unlink (CONFFILE);
 
 	if (failed)
 		g_signal_emit_by_name (self, NM_DNS_PLUGIN_FAILED);
@@ -410,7 +574,13 @@ nm_dns_dnsmasq_init (NMDnsDnsmasq *self)
 static void
 dispose (GObject *object)
 {
-	unlink (CONFFILE);
+	NMDnsDnsmasqPrivate *priv = NM_DNS_DNSMASQ_GET_PRIVATE (object);
+
+	nm_clear_g_cancellable (&priv->dnsmasq_cancellable);
+
+	g_clear_object (&priv->dnsmasq);
+
+	g_clear_pointer (&priv->set_servers_ex_args, g_variant_builder_unref);
 
 	G_OBJECT_CLASS (nm_dns_dnsmasq_parent_class)->dispose (object);
 }
Index: b/src/dns-manager/nm-dns-manager.c
===================================================================
--- a/src/dns-manager/nm-dns-manager.c
+++ b/src/dns-manager/nm-dns-manager.c
@@ -1065,6 +1065,24 @@ update_dns (NMDnsManager *self,
 }
 
 static void
+plugin_appeared (NMDnsPlugin *plugin, gpointer user_data)
+{
+	NMDnsManager *self = NM_DNS_MANAGER (user_data);
+	GError *error = NULL;
+
+	/* Not applicable to non-caching plugins */
+	if (!nm_dns_plugin_is_caching (plugin))
+		return;
+
+	/* Try to update DNS again; since it's now available on the bus this
+	 * might work. */
+	if (!update_dns (self, FALSE, &error)) {
+		_LOGW ("could not commit DNS changes: %s", error->message);
+		g_clear_error (&error);
+	}
+}
+
+static void
 plugin_failed (NMDnsPlugin *plugin, gpointer user_data)
 {
 	NMDnsManager *self = NM_DNS_MANAGER (user_data);
@@ -1432,6 +1450,7 @@ init_resolv_conf_mode (NMDnsManager *sel
 
 		g_signal_connect (priv->plugin, NM_DNS_PLUGIN_FAILED, G_CALLBACK (plugin_failed), self);
 		g_signal_connect (priv->plugin, NM_DNS_PLUGIN_CHILD_QUIT, G_CALLBACK (plugin_child_quit), self);
+		g_signal_connect (priv->plugin, NM_DNS_PLUGIN_APPEARED, G_CALLBACK (plugin_appeared), self);
 
 		_NMLOG (immutable ? LOGL_WARN : LOGL_INFO,
 		        "%s%s%s%s%s%s",
Index: b/src/dns-manager/nm-dns-plugin.c
===================================================================
--- a/src/dns-manager/nm-dns-plugin.c
+++ b/src/dns-manager/nm-dns-plugin.c
@@ -43,6 +43,7 @@ G_DEFINE_TYPE_EXTENDED (NMDnsPlugin, nm_
 
 enum {
 	FAILED,
+	APPEARED,
 	CHILD_QUIT,
 	LAST_SIGNAL
 };
@@ -159,6 +160,12 @@ watch_cb (GPid pid, gint status, gpointe
 
 	_clear_pidfile (self);
 
+	if (priv->pidfile) {
+		unlink (priv->pidfile);
+		g_free (priv->pidfile);
+		priv->pidfile = NULL;
+	}
+
 	g_signal_emit (self, signals[CHILD_QUIT], 0, status);
 }
 
@@ -273,7 +280,16 @@ nm_dns_plugin_class_init (NMDnsPluginCla
 	                  G_OBJECT_CLASS_TYPE (object_class),
 	                  G_SIGNAL_RUN_FIRST,
 	                  G_STRUCT_OFFSET (NMDnsPluginClass, failed),
-	                  NULL, NULL,
+					  NULL, NULL,
+					  g_cclosure_marshal_VOID__VOID,
+					  G_TYPE_NONE, 0);
+
+	signals[APPEARED] =
+		g_signal_new (NM_DNS_PLUGIN_APPEARED,
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMDnsPluginClass, failed),
+					  NULL, NULL,
 	                  g_cclosure_marshal_VOID__VOID,
 	                  G_TYPE_NONE, 0);
 
Index: b/src/dns-manager/nm-dns-plugin.h
===================================================================
--- a/src/dns-manager/nm-dns-plugin.h
+++ b/src/dns-manager/nm-dns-plugin.h
@@ -31,6 +31,7 @@
 #define NM_DNS_PLUGIN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DNS_PLUGIN, NMDnsPluginClass))
 
 #define NM_DNS_PLUGIN_FAILED "failed"
+#define NM_DNS_PLUGIN_APPEARED "appeared"
 #define NM_DNS_PLUGIN_CHILD_QUIT "child-quit"
 
 #define IP_CONFIG_IFACE_TAG "dns-manager-iface"
Index: b/src/org.freedesktop.NetworkManager.conf
===================================================================
--- a/src/org.freedesktop.NetworkManager.conf
+++ b/src/org.freedesktop.NetworkManager.conf
@@ -26,6 +26,13 @@
                 <allow send_destination="org.freedesktop.NetworkManager.fortisslvpn"/>
                 <allow send_destination="org.freedesktop.NetworkManager.strongswan"/>
                 <allow send_interface="org.freedesktop.NetworkManager.VPN.Plugin"/>
+
+                <!-- Allow the custom name for the dnsmasq instance spawned by NM
+                     from the dns dnsmasq plugin to own it's dbus name, and for
+                     messages to be sent to it.
+                 -->
+                <allow own="org.freedesktop.NetworkManager.dnsmasq"/>
+                <allow send_destination="org.freedesktop.NetworkManager.dnsmasq"/>
         </policy>
         <policy user="whoopsie">
                 <allow send_destination="org.freedesktop.NetworkManager"/>
@@ -145,6 +152,9 @@
                 <deny send_destination="org.freedesktop.NetworkManager"
                       send_interface="org.freedesktop.NetworkManager.Settings"
                       send_member="ReloadConnections"/>
+
+                <deny own="org.freedesktop.NetworkManager.dnsmasq"/>
+                <deny send_destination="org.freedesktop.NetworkManager.dnsmasq"/>
         </policy>
 
 	<limit name="max_replies_per_connection">1024</limit>
