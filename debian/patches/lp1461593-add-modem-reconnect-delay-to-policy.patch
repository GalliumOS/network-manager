Author: Tony Espy <espy@canonical.com>
Subject: Introduce NMPolicy delay for modem activate retries

This patch introduces a 5s delay between retry activations
for modem devices.  Otherwise, the activation attempts can
flood the modem all at once, and then trigger the reset_retries
timeout ( which defaults to 300s ).

Bug: https://bugs.launchpad.net/ubuntu/+source/network-manager/+bug/1461593

---

---
 src/nm-policy.c |   36 +++++++++++++++++++++++++++++-------
 1 file changed, 29 insertions(+), 7 deletions(-)

Index: b/src/nm-policy.c
===================================================================
--- a/src/nm-policy.c
+++ b/src/nm-policy.c
@@ -901,7 +901,7 @@ sleeping_changed (NMManager *manager, GP
 }
 
 static void
-schedule_activate_check (NMPolicy *policy, NMDevice *device)
+schedule_activate_check (NMPolicy *policy, NMDevice *device, guint delay)
 {
 	NMPolicyPrivate *priv = NM_POLICY_GET_PRIVATE (policy);
 	ActivateData *data;
@@ -930,7 +930,12 @@ schedule_activate_check (NMPolicy *polic
 	data = g_malloc0 (sizeof (ActivateData));
 	data->policy = policy;
 	data->device = g_object_ref (device);
-	data->autoactivate_id = g_idle_add (auto_activate_device, data);
+
+	if (delay)
+		data->autoactivate_id = g_timeout_add_seconds (delay, auto_activate_device, data);
+	else
+		data->autoactivate_id = g_idle_add (auto_activate_device, data);
+
 	priv->pending_activation_checks = g_slist_append (priv->pending_activation_checks, data);
 }
 
@@ -1125,6 +1130,7 @@ device_state_changed (NMDevice *device,
 	NMIP4Config *ip4_config;
 	NMIP6Config *ip6_config;
 	NMSettingConnection *s_con = NULL;
+	guint delay = 0;
 
 	switch (new_state) {
 	case NM_DEVICE_STATE_FAILED:
@@ -1153,9 +1159,14 @@ device_state_changed (NMDevice *device,
 				/* Schedule a handler to reset retries count */
 				if (!priv->reset_retries_id) {
 					gint32 retry_time = nm_settings_connection_get_autoconnect_retry_time (connection);
+					gint32 actual_time = MAX (0, retry_time - nm_utils_get_monotonic_timestamp_s ());
+
+					nm_log_info (LOGD_DEVICE, "Disabling autoconnect for connection '%s'; setting retry of %d.",
+					             nm_connection_get_id (NM_CONNECTION (connection)), actual_time);
+
 
 					g_warn_if_fail (retry_time != 0);
-					priv->reset_retries_id = g_timeout_add_seconds (MAX (0, retry_time - nm_utils_get_monotonic_timestamp_s ()), reset_connections_retries, policy);
+					priv->reset_retries_id = g_timeout_add_seconds (actual_time, reset_connections_retries, policy);
 				}
 			}
 			nm_connection_clear_secrets (NM_CONNECTION (connection));
@@ -1220,7 +1231,18 @@ device_state_changed (NMDevice *device,
 			update_routing_and_dns (policy, FALSE);
 
 		/* Device is now available for auto-activation */
-		schedule_activate_check (policy, device);
+
+		if (nm_device_get_device_type (device) == NM_DEVICE_TYPE_MODEM)
+			delay = 5;
+
+		if (connection)
+			nm_log_info (LOGD_DEVICE, "Connection '%s' disconnected, scheduling activate_check in %u seconds.",
+			             nm_connection_get_id (NM_CONNECTION (connection)), delay);
+		else
+			nm_log_info (LOGD_DEVICE, "Device '%s' has no connection; scheduling activate_check in %u seconds.",
+			             nm_device_get_iface (device), delay);
+
+		schedule_activate_check (policy, device, delay);
 		break;
 
 	case NM_DEVICE_STATE_PREPARE:
@@ -1330,13 +1352,13 @@ device_autoconnect_changed (NMDevice *de
                             gpointer user_data)
 {
 	if (nm_device_autoconnect_allowed (device))
-		schedule_activate_check ((NMPolicy *) user_data, device);
+		schedule_activate_check ((NMPolicy *) user_data, device, 0);
 }
 
 static void
 device_recheck_auto_activate (NMDevice *device, gpointer user_data)
 {
-	schedule_activate_check (NM_POLICY (user_data), device);
+	schedule_activate_check (NM_POLICY (user_data), device, 0);
 }
 
 typedef struct {
@@ -1561,7 +1583,7 @@ schedule_activate_all (NMPolicy *policy)
 	const GSList *iter;
 
 	for (iter = nm_manager_get_devices (priv->manager); iter; iter = g_slist_next (iter))
-		schedule_activate_check (policy, NM_DEVICE (iter->data));
+		schedule_activate_check (policy, NM_DEVICE (iter->data), 0);
 }
 
 static void
