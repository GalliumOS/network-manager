From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Subject: Don't break bridges NM didn't create.
Forwarded: not-needed
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/network-manager/+bug/1444205

This effectively reverts upstream commit ce810d3660c32aa547bc5ea4d60aaa882d2bb7f0.

In Ubuntu we don't use NM as aggressively as in Fedora or elsewhere, it's not
usually running on servers, and actually gets in the way of libvirt and other
virtualization tools when it tries to start and assume connections (or restart).

Reinstating the nm_bridges code makes NM keep track of which bridges it did
setup, so others are left well alone.

---
 src/nm-manager.c |  113 ++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 111 insertions(+), 2 deletions(-)

Index: b/src/nm-manager.c
===================================================================
--- a/src/nm-manager.c
+++ b/src/nm-manager.c
@@ -207,6 +207,8 @@ typedef struct {
 
 	GSList *auth_chains;
 
+	GHashTable *nm_bridges;
+
 	/* Firmware dir monitor */
 	GFileMonitor *fw_monitor;
 	guint fw_changed_id;
@@ -1093,6 +1095,90 @@ connection_needs_virtual_device (NMConne
 
 /***************************/
 
+/* FIXME: remove when we handle bridges non-destructively */
+
+#define NM_BRIDGE_FILE  NMRUNDIR "/nm-bridges"
+
+static void
+read_nm_created_bridges (NMManager *self)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	char *contents;
+	char **lines, **iter;
+	GTimeVal tv;
+	glong ts;
+
+	if (!g_file_get_contents (NM_BRIDGE_FILE, &contents, NULL, NULL))
+		return;
+
+	g_get_current_time (&tv);
+
+	lines = g_strsplit_set (contents, "\n", 0);
+	g_free (contents);
+
+	for (iter = lines; iter && *iter; iter++) {
+		if (g_str_has_prefix (*iter, "ts=")) {
+			errno = 0;
+			ts = strtol (*iter + 3, NULL, 10);
+			/* allow 30 minutes time difference before we ignore the file */
+			if (errno || ABS (tv.tv_sec - ts) > 1800)
+				goto out;
+		} else if (g_str_has_prefix (*iter, "iface="))
+			g_hash_table_insert (priv->nm_bridges, g_strdup (*iter + 6), GUINT_TO_POINTER (1));
+	}
+
+out:
+	g_strfreev (lines);
+	unlink (NM_BRIDGE_FILE);
+}
+
+static void
+write_nm_created_bridges (NMManager *self)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	GString *br_list;
+	GSList *iter;
+	GError *error = NULL;
+	GTimeVal tv;
+	gboolean found = FALSE;
+
+	/* write out nm-created bridges list */
+	br_list = g_string_sized_new (50);
+
+	/* Timestamp is first line */
+	g_get_current_time (&tv);
+	g_string_append_printf (br_list, "ts=%ld\n", tv.tv_sec);
+
+	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+		NMDevice *device = iter->data;
+
+		if (nm_device_get_device_type (device) == NM_DEVICE_TYPE_BRIDGE) {
+			g_string_append_printf (br_list, "iface=%s\n", nm_device_get_iface (device));
+			found = TRUE;
+		}
+	}
+
+	if (found) {
+		if (!g_file_set_contents (NM_BRIDGE_FILE, br_list->str, -1, &error)) {
+			nm_log_warn (LOGD_BRIDGE, "Failed to write NetworkManager-created bridge list; "
+			             "on restart bridges may not be recognized. (%s)",
+			             error ? error->message : "unknown");
+			g_clear_error (&error);
+		}
+	}
+	g_string_free (br_list, TRUE);
+}
+
+static gboolean
+bridge_created_by_nm (NMManager *self, const char *iface)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+
+	return (priv->nm_bridges && g_hash_table_lookup (priv->nm_bridges, iface));
+}
+
+/***************************/
+
 /**
  * system_create_virtual_device:
  * @self: the #NMManager
@@ -1138,7 +1224,12 @@ system_create_virtual_device (NMManager
 	} else if (nm_connection_is_type (connection, NM_SETTING_TEAM_SETTING_NAME)) {
 		device = nm_device_team_new_for_connection (connection);
 	} else if (nm_connection_is_type (connection, NM_SETTING_BRIDGE_SETTING_NAME)) {
-		device = nm_device_bridge_new_for_connection (connection);
+		/* FIXME: remove when we handle bridges non-destructively */
+		if (nm_platform_link_get_ifindex (iface) > 0 && !bridge_created_by_nm (self, iface)) {
+			nm_log_warn (LOGD_DEVICE, "(%s): cannot use existing bridge for '%s'",
+			             iface, nm_connection_get_id (connection));
+		} else
+			device = nm_device_bridge_new_for_connection (connection);
 	} else if (nm_connection_is_type (connection, NM_SETTING_VLAN_SETTING_NAME)) {
 		device = nm_device_vlan_new_for_connection (connection, parent);
 	} else if (nm_connection_is_type (connection, NM_SETTING_INFINIBAND_SETTING_NAME)) {
@@ -2079,7 +2170,11 @@ platform_link_added (NMManager *self,
 			device = nm_device_team_new (plink);
 			break;
 		case NM_LINK_TYPE_BRIDGE:
-			device = nm_device_bridge_new (plink);
+			/* FIXME: always create device when we handle bridges non-destructively */
+			if (bridge_created_by_nm (self, plink->name))
+				device = nm_device_bridge_new (plink);
+			else
+				nm_log_info (LOGD_BRIDGE, "(%s): ignoring bridge not created by NetworkManager", plink->name);
 			break;
 		case NM_LINK_TYPE_VLAN:
 			/* Have to find the parent device */
@@ -4197,6 +4292,13 @@ nm_manager_start (NMManager *self)
 	system_unmanaged_devices_changed_cb (priv->settings, NULL, self);
 	system_hostname_changed_cb (priv->settings, NULL, self);
 
+	/* FIXME: remove when we handle bridges non-destructively */
+	/* Read a list of bridges NM managed when it last quit, and only
+	 * manage those bridges to avoid conflicts with external tools.
+	 */
+	priv->nm_bridges = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+	read_nm_created_bridges (self);
+
 	nm_platform_query_devices ();
 
 	/*
@@ -4205,6 +4307,10 @@ nm_manager_start (NMManager *self)
 	 */
 	system_create_virtual_devices (self);
 
+	/* FIXME: remove when we handle bridges non-destructively */
+	g_hash_table_unref (priv->nm_bridges);
+	priv->nm_bridges = NULL;
+
 	check_if_startup_complete (self);
 
 	/* Trigger ifupdown state file check */
@@ -5044,6 +5150,9 @@ dispose (GObject *object)
 
 	nm_auth_changed_func_unregister (authority_changed_cb, manager);
 
+	/* FIXME: remove when we handle bridges non-destructively */
+	write_nm_created_bridges (manager);
+
 	/* Remove all devices */
 	while (priv->devices)
 		remove_device (manager, NM_DEVICE (priv->devices->data), TRUE);
