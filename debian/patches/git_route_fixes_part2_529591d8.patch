From 0f1fca29dbe6f8d7909b8e85fb98b358bab4e27a Mon Sep 17 00:00:00 2001
From: Thomas Haller <thaller@redhat.com>
Date: Sun, 11 Jan 2015 18:17:47 +0100
Subject: platform/tests: fix errors in fake platform handling route metrics


---
 src/platform/nm-fake-platform.c  |    8 ++++++++
 src/platform/nm-linux-platform.c |    5 ++++-
 src/platform/nm-platform.c       |    3 +--
 src/platform/nm-platform.h       |    5 ++++-
 4 files changed, 17 insertions(+), 4 deletions(-)

Index: b/src/platform/nm-fake-platform.c
===================================================================
--- a/src/platform/nm-fake-platform.c
+++ b/src/platform/nm-fake-platform.c
@@ -1066,6 +1066,8 @@ ip4_route_add (NMPlatform *platform, int
 			continue;
 		if (item->plen != route.plen)
 			continue;
+		if (item->metric != metric)
+			continue;
 
 		memcpy (item, &route, sizeof (route));
 		g_signal_emit_by_name (platform, NM_PLATFORM_SIGNAL_IP4_ROUTE_CHANGED, ifindex, &route, NM_PLATFORM_SIGNAL_CHANGED, NM_PLATFORM_REASON_INTERNAL);
@@ -1087,6 +1089,8 @@ ip6_route_add (NMPlatform *platform, int
 	NMPlatformIP6Route route;
 	guint i;
 
+	metric = nm_utils_ip6_route_metric_normalize (metric);
+
 	memset (&route, 0, sizeof (route));
 	route.source = NM_PLATFORM_SOURCE_KERNEL;
 	route.ifindex = ifindex;
@@ -1106,6 +1110,8 @@ ip6_route_add (NMPlatform *platform, int
 			continue;
 		if (item->plen != route.plen)
 			continue;
+		if (item->metric != metric)
+			continue;
 
 		memcpy (item, &route, sizeof (route));
 		g_signal_emit_by_name (platform, NM_PLATFORM_SIGNAL_IP6_ROUTE_CHANGED, ifindex, &route, NM_PLATFORM_SIGNAL_CHANGED, NM_PLATFORM_REASON_INTERNAL);
@@ -1143,6 +1149,8 @@ ip6_route_get (NMPlatform *platform, int
 	NMFakePlatformPrivate *priv = NM_FAKE_PLATFORM_GET_PRIVATE (platform);
 	int i;
 
+	metric = nm_utils_ip6_route_metric_normalize (metric);
+
 	for (i = 0; i < priv->ip6_routes->len; i++) {
 		NMPlatformIP6Route *route = &g_array_index (priv->ip6_routes, NMPlatformIP6Route, i);
 
Index: b/src/platform/nm-linux-platform.c
===================================================================
--- a/src/platform/nm-linux-platform.c
+++ b/src/platform/nm-linux-platform.c
@@ -1524,6 +1524,9 @@ announce_object (NMPlatform *platform, c
 	ObjectType object_type = object_type_from_nl_object (object);
 	const char *sig = signal_by_type_and_status[object_type];
 
+	if (reason == _NM_PLATFORM_REASON_CACHE_CHECK_INTERNAL)
+		return;
+
 	switch (object_type) {
 	case OBJECT_TYPE_LINK:
 		{
@@ -3707,7 +3710,7 @@ ip4_route_delete (NMPlatform *platform,
 		 *
 		 * Instead, re-fetch the route from kernel, and if that fails, there is nothing to do.
 		 * On success, there is still a race that we might end up deleting the wrong route. */
-		if (!refresh_object (platform, (struct nl_object *) route, FALSE, NM_PLATFORM_REASON_INTERNAL)) {
+		if (!refresh_object (platform, (struct nl_object *) route, FALSE, _NM_PLATFORM_REASON_CACHE_CHECK_INTERNAL)) {
 			rtnl_route_put ((struct rtnl_route *) route);
 			return TRUE;
 		}
Index: b/src/platform/nm-platform.h
===================================================================
--- a/src/platform/nm-platform.h
+++ b/src/platform/nm-platform.h
@@ -69,7 +69,10 @@ typedef enum {
 	/* Event came from the kernel. */
 	NM_PLATFORM_REASON_EXTERNAL,
 	/* Event is a result of cache checking and cleanups. */
-	NM_PLATFORM_REASON_CACHE_CHECK
+	NM_PLATFORM_REASON_CACHE_CHECK,
+
+	/* Internal reason to suppress announcing change events */
+	_NM_PLATFORM_REASON_CACHE_CHECK_INTERNAL,
 } NMPlatformReason;
 
 typedef enum {
Index: b/src/platform/nm-platform.c
===================================================================
--- a/src/platform/nm-platform.c
+++ b/src/platform/nm-platform.c
@@ -1888,8 +1888,7 @@ array_contains_ip4_route (const GArray *
 
 		if (route->network == c->network &&
 		    route->plen == c->plen &&
-		    route->gateway == c->gateway &&
-		    route->metric == c->metric)
+		    route->gateway == c->gateway)
 			return TRUE;
 	}
 
