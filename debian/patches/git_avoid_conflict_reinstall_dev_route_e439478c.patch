From 5849c97c0368d51ea35590736aaf40ee522fed0d Mon Sep 17 00:00:00 2001
From: Thomas Haller <thaller@redhat.com>
Date: Wed, 26 Nov 2014 00:10:04 +0100
Subject: platform: avoid conflicts when reinstalling the device-route

Since f32075d2fc11252e5661166b2f46c18c017929e9, we remove the kernel
added IPv4 device route, and re-add it with appropriate metric.

This could potentially replace existing, conflicting routes. Be more
careful and only take any action when we don't have a conflicting
route and when we add the address for the first time.

The motivation for this was libreswan which might install a VPN route
for a subnet that we also have configured on an interface. But the route
conflict could happen easily for other reasons, for example if you
configure a conflicting route manually.

Don't replace the device route if we have any indication that
a conflict could arise.

https://bugzilla.gnome.org/show_bug.cgi?id=723178

---
 src/devices/nm-device.c             |    3 +
 src/nm-ip4-config.c                 |    4 +-
 src/nm-ip4-config.h                 |    2 -
 src/platform/nm-fake-platform.c     |    8 +++++
 src/platform/nm-linux-platform.c    |   56 ++++++++++++++++++++++++++++++++----
 src/platform/nm-platform.c          |   48 +++++++++++++++++++++++++++++-
 src/platform/nm-platform.h          |   19 +++++++++++-
 src/vpn-manager/nm-vpn-connection.c |    5 ++-
 8 files changed, 132 insertions(+), 13 deletions(-)

Index: b/src/platform/nm-fake-platform.c
===================================================================
--- a/src/platform/nm-fake-platform.c
+++ b/src/platform/nm-fake-platform.c
@@ -978,6 +978,12 @@ ip6_address_exists (NMPlatform *platform
 	return FALSE;
 }
 
+static gboolean
+ip4_check_reinstall_device_route (NMPlatform *platform, int ifindex, const NMPlatformIP4Address *address, guint32 device_route_metric)
+{
+	return FALSE;
+}
+
 /******************************************************************/
 
 static GArray *
@@ -1349,6 +1355,8 @@ nm_fake_platform_class_init (NMFakePlatf
 	platform_class->ip4_address_exists = ip4_address_exists;
 	platform_class->ip6_address_exists = ip6_address_exists;
 
+	platform_class->ip4_check_reinstall_device_route = ip4_check_reinstall_device_route;
+
 	platform_class->ip4_route_get_all = ip4_route_get_all;
 	platform_class->ip6_route_get_all = ip6_route_get_all;
 	platform_class->ip4_route_add = ip4_route_add;
Index: b/src/platform/nm-linux-platform.c
===================================================================
--- a/src/platform/nm-linux-platform.c
+++ b/src/platform/nm-linux-platform.c
@@ -90,6 +90,7 @@ typedef struct {
 G_DEFINE_TYPE (NMLinuxPlatform, nm_linux_platform, NM_TYPE_PLATFORM)
 
 static const char *to_string_object (NMPlatform *platform, struct nl_object *obj);
+static gboolean _route_match (struct rtnl_route *rtnlroute, int family, int ifindex, gboolean include_proto_kernel);
 
 void
 nm_linux_platform_setup (void)
@@ -3499,10 +3500,53 @@ ip6_address_exists (NMPlatform *platform
 	return ip_address_exists (platform, AF_INET6, ifindex, &addr, plen);
 }
 
+static gboolean
+ip4_check_reinstall_device_route (NMPlatform *platform, int ifindex, const NMPlatformIP4Address *address, guint32 device_route_metric)
+{
+	NMLinuxPlatformPrivate *priv = NM_LINUX_PLATFORM_GET_PRIVATE (platform);
+	NMPlatformIP4Address addr_candidate;
+	NMPlatformIP4Route route_candidate;
+	struct nl_object *object;
+	guint32 device_network;
+
+	for (object = nl_cache_get_first (priv->address_cache); object; object = nl_cache_get_next (object)) {
+		if (_address_match ((struct rtnl_addr *) object, AF_INET, 0)) {
+			if (init_ip4_address (&addr_candidate, (struct rtnl_addr *) object))
+				if (   addr_candidate.plen == address->plen
+				    && addr_candidate.address == address->address) {
+					/* If we already have the same address installed on any interface,
+					 * we back off.
+					 * Perform this check first, as we expect to have significantly less
+					 * addresses to search. */
+					return FALSE;
+				}
+		}
+	}
+
+	device_network = nm_utils_ip4_address_clear_host_address (address->address, address->plen);
+
+	for (object = nl_cache_get_first (priv->route_cache); object; object = nl_cache_get_next (object)) {
+		if (_route_match ((struct rtnl_route *) object, AF_INET, 0, TRUE)) {
+			if (init_ip4_route (&route_candidate, (struct rtnl_route *) object)) {
+				if (   route_candidate.network == device_network
+				    && route_candidate.plen == address->plen
+				    && (   route_candidate.metric == 0
+				        || route_candidate.metric == device_route_metric)) {
+					/* There is already any route with metric 0 or the metric we want to install
+					 * for the same subnet. */
+					return FALSE;
+				}
+			}
+		}
+	}
+
+	return TRUE;
+}
+
 /******************************************************************/
 
 static gboolean
-_route_match (struct rtnl_route *rtnlroute, int family, int ifindex)
+_route_match (struct rtnl_route *rtnlroute, int family, int ifindex, gboolean include_proto_kernel)
 {
 	struct rtnl_nexthop *nexthop;
 
@@ -3510,7 +3554,7 @@ _route_match (struct rtnl_route *rtnlrou
 
 	if (rtnl_route_get_type (rtnlroute) != RTN_UNICAST ||
 	    rtnl_route_get_table (rtnlroute) != RT_TABLE_MAIN ||
-	    rtnl_route_get_protocol (rtnlroute) == RTPROT_KERNEL ||
+	    (!include_proto_kernel && rtnl_route_get_protocol (rtnlroute) == RTPROT_KERNEL) ||
 	    rtnl_route_get_family (rtnlroute) != family ||
 	    rtnl_route_get_nnexthops (rtnlroute) != 1 ||
 	    rtnl_route_get_flags (rtnlroute) & RTM_F_CLONED)
@@ -3531,7 +3575,7 @@ ip4_route_get_all (NMPlatform *platform,
 	routes = g_array_new (FALSE, FALSE, sizeof (NMPlatformIP4Route));
 
 	for (object = nl_cache_get_first (priv->route_cache); object; object = nl_cache_get_next (object)) {
-		if (_route_match ((struct rtnl_route *) object, AF_INET, ifindex)) {
+		if (_route_match ((struct rtnl_route *) object, AF_INET, ifindex, FALSE)) {
 			if (init_ip4_route (&route, (struct rtnl_route *) object)) {
 				if (!NM_PLATFORM_IP_ROUTE_IS_DEFAULT (&route) || include_default)
 					g_array_append_val (routes, route);
@@ -3553,7 +3597,7 @@ ip6_route_get_all (NMPlatform *platform,
 	routes = g_array_new (FALSE, FALSE, sizeof (NMPlatformIP6Route));
 
 	for (object = nl_cache_get_first (priv->route_cache); object; object = nl_cache_get_next (object)) {
-		if (_route_match ((struct rtnl_route *) object, AF_INET6, ifindex)) {
+		if (_route_match ((struct rtnl_route *) object, AF_INET6, ifindex, FALSE)) {
 			if (init_ip6_route (&route, (struct rtnl_route *) object)) {
 				if (!NM_PLATFORM_IP_ROUTE_IS_DEFAULT (&route) || include_default)
 					g_array_append_val (routes, route);
@@ -3653,7 +3697,7 @@ route_search_cache (struct nl_cache *cac
 		struct nl_addr *dst;
 		struct rtnl_route *rtnlroute = (struct rtnl_route *) object;
 
-		if (!_route_match (rtnlroute, family, ifindex))
+		if (!_route_match (rtnlroute, family, ifindex, FALSE))
 			continue;
 
 		if (metric != rtnl_route_get_priority (rtnlroute))
@@ -4200,6 +4244,8 @@ nm_linux_platform_class_init (NMLinuxPla
 	platform_class->ip4_address_exists = ip4_address_exists;
 	platform_class->ip6_address_exists = ip6_address_exists;
 
+	platform_class->ip4_check_reinstall_device_route = ip4_check_reinstall_device_route;
+
 	platform_class->ip4_route_get_all = ip4_route_get_all;
 	platform_class->ip6_route_get_all = ip6_route_get_all;
 	platform_class->ip4_route_add = ip4_route_add;
Index: b/src/platform/nm-platform.c
===================================================================
--- a/src/platform/nm-platform.c
+++ b/src/platform/nm-platform.c
@@ -1642,6 +1642,25 @@ _address_get_lifetime (const NMPlatformI
 	return TRUE;
 }
 
+gboolean
+nm_platform_ip4_check_reinstall_device_route (int ifindex, const NMPlatformIP4Address *address, guint32 device_route_metric)
+{
+	g_return_val_if_fail (address, FALSE);
+
+	if (   ifindex <= 0
+	    || address->plen <= 0
+	    || address->plen >= 32)
+		return FALSE;
+
+	if (device_route_metric == NM_PLATFORM_ROUTE_METRIC_IP4_DEVICE_ROUTE) {
+		/* The automatically added route would be already our desired priority.
+		 * Nothing to do. */
+		return FALSE;
+	}
+
+	return klass->ip4_check_reinstall_device_route (platform, ifindex, address, device_route_metric);
+}
+
 /**
  * nm_platform_ip4_address_sync:
  * @ifindex: Interface index
@@ -1654,7 +1673,7 @@ _address_get_lifetime (const NMPlatformI
  * Returns: %TRUE on success.
  */
 gboolean
-nm_platform_ip4_address_sync (int ifindex, const GArray *known_addresses)
+nm_platform_ip4_address_sync (int ifindex, const GArray *known_addresses, guint32 device_route_metric)
 {
 	GArray *addresses;
 	NMPlatformIP4Address *address;
@@ -1678,6 +1697,15 @@ nm_platform_ip4_address_sync (int ifinde
 	for (i = 0; i < known_addresses->len; i++) {
 		const NMPlatformIP4Address *known_address = &g_array_index (known_addresses, NMPlatformIP4Address, i);
 		guint32 lifetime, preferred;
+ 		guint32 network;
+		gboolean reinstall_device_route = FALSE;
+
+ 		/* add a padding of 5 seconds to avoid potential races. */
+ 		if (!_address_get_lifetime ((NMPlatformIPAddress *) known_address, now, 5, &lifetime, &preferred))
+ 			continue;
+
+		if (nm_platform_ip4_check_reinstall_device_route (ifindex, known_address, device_route_metric))
+			reinstall_device_route = TRUE;
 
 		/* add a padding of 5 seconds to avoid potential races. */
 		if (!_address_get_lifetime ((NMPlatformIPAddress *) known_address, now, 5, &lifetime, &preferred))
@@ -1685,6 +1713,22 @@ nm_platform_ip4_address_sync (int ifinde
 
 		if (!nm_platform_ip4_address_add (ifindex, known_address->address, known_address->peer_address, known_address->plen, lifetime, preferred, known_address->label))
 			return FALSE;
+
+		if (reinstall_device_route) {
+			/* Kernel automatically adds a device route for us with metric 0. That is not what we want.
+			 * Remove it, and re-add it.
+			 *
+			 * In face of having the same subnets on two different interfaces with the same metric,
+			 * this is a problem. Surprisingly, kernel is able to add two routes for the same subnet/prefix,metric
+			 * to different interfaces. We cannot. Adding one, would replace the other. This is avoided
+			 * by the above nm_platform_ip4_check_reinstall_device_route() check.
+			 */
+			network = nm_utils_ip4_address_clear_host_address (known_address->address, known_address->plen);
+			(void) nm_platform_ip4_route_add (ifindex, NM_PLATFORM_SOURCE_KERNEL, network, known_address->plen,
+			                                  0, device_route_metric, 0);
+			(void) nm_platform_ip4_route_delete (ifindex, network, known_address->plen,
+			                                     NM_PLATFORM_ROUTE_METRIC_IP4_DEVICE_ROUTE);
+ 		}
 	}
 
 	return TRUE;
@@ -1747,7 +1791,7 @@ nm_platform_ip6_address_sync (int ifinde
 gboolean
 nm_platform_address_flush (int ifindex)
 {
-	return nm_platform_ip4_address_sync (ifindex, NULL)
+	return nm_platform_ip4_address_sync (ifindex, NULL, 0)
 			&& nm_platform_ip6_address_sync (ifindex, NULL);
 }
 
Index: b/src/platform/nm-platform.h
===================================================================
--- a/src/platform/nm-platform.h
+++ b/src/platform/nm-platform.h
@@ -164,6 +164,19 @@ typedef struct {
 	__NMPlatformObject_COMMON;
 } NMPlatformObject;
 
+/* Default value for adding an IPv4 route. This is also what iproute2 does.
+ * Note that contrary to IPv6, you can add routes with metric 0 and it is even
+ * the default.
+ */
+#define NM_PLATFORM_ROUTE_METRIC_DEFAULT_IP4 0
+
+/* Default value for adding an IPv6 route. This is also what iproute2 does.
+ * Adding an IPv6 route with metric 0, kernel translates to IP6_RT_PRIO_USER (1024). */
+#define NM_PLATFORM_ROUTE_METRIC_DEFAULT_IP6 1024
+
+/* For IPv4, kernel adds a device route (subnet routes) with metric 0 when user
+ * configures addresses. */
+#define NM_PLATFORM_ROUTE_METRIC_IP4_DEVICE_ROUTE 0
 
 #define __NMPlatformIPAddress_COMMON \
 	__NMPlatformObject_COMMON; \
@@ -452,6 +465,8 @@ typedef struct {
 	gboolean (*ip4_address_exists) (NMPlatform *, int ifindex, in_addr_t address, int plen);
 	gboolean (*ip6_address_exists) (NMPlatform *, int ifindex, struct in6_addr address, int plen);
 
+	gboolean (*ip4_check_reinstall_device_route) (NMPlatform *, int ifindex, const NMPlatformIP4Address *address, guint32 device_route_metric);
+
 	GArray * (*ip4_route_get_all) (NMPlatform *, int ifindex, gboolean include_default);
 	GArray * (*ip6_route_get_all) (NMPlatform *, int ifindex, gboolean include_default);
 	gboolean (*ip4_route_add) (NMPlatform *, int ifindex, NMPlatformSource source,
@@ -592,10 +607,12 @@ gboolean nm_platform_ip4_address_delete
 gboolean nm_platform_ip6_address_delete (int ifindex, struct in6_addr address, int plen);
 gboolean nm_platform_ip4_address_exists (int ifindex, in_addr_t address, int plen);
 gboolean nm_platform_ip6_address_exists (int ifindex, struct in6_addr address, int plen);
-gboolean nm_platform_ip4_address_sync (int ifindex, const GArray *known_addresses);
+gboolean nm_platform_ip4_address_sync (int ifindex, const GArray *known_addresses, guint32 default_route_metric);
 gboolean nm_platform_ip6_address_sync (int ifindex, const GArray *known_addresses);
 gboolean nm_platform_address_flush (int ifindex);
 
+gboolean nm_platform_ip4_check_reinstall_device_route (int ifindex, const NMPlatformIP4Address *address, guint32 device_route_metric);
+
 GArray *nm_platform_ip4_route_get_all (int ifindex, gboolean include_default);
 GArray *nm_platform_ip6_route_get_all (int ifindex, gboolean include_default);
 gboolean nm_platform_route_set_metric (int ifindex, int metric);
Index: b/src/devices/nm-device.c
===================================================================
--- a/src/devices/nm-device.c
+++ b/src/devices/nm-device.c
@@ -5079,7 +5079,8 @@ nm_device_set_ip4_config (NMDevice *self
 
 	/* Always commit to nm-platform to update lifetimes */
 	if (commit && new_config) {
-		success = nm_ip4_config_commit (new_config, ip_ifindex);
+		success = nm_ip4_config_commit (new_config, ip_ifindex,
+		                                nm_device_get_priority (self));
 		if (!success)
 			reason_local = NM_DEVICE_STATE_REASON_CONFIG_FAILED;
 	}
Index: b/src/nm-ip4-config.c
===================================================================
--- a/src/nm-ip4-config.c
+++ b/src/nm-ip4-config.c
@@ -244,7 +244,7 @@ nm_ip4_config_capture (int ifindex, gboo
 }
 
 gboolean
-nm_ip4_config_commit (const NMIP4Config *config, int ifindex)
+nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)
 {
 	NMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);
 	int mtu = nm_ip4_config_get_mtu (config);
@@ -254,7 +254,7 @@ nm_ip4_config_commit (const NMIP4Config
 	g_return_val_if_fail (config != NULL, FALSE);
 
 	/* Addresses */
-	nm_platform_ip4_address_sync (ifindex, priv->addresses);
+	nm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);
 
 	/* Routes */
 	{
Index: b/src/vpn-manager/nm-vpn-connection.c
===================================================================
--- a/src/vpn-manager/nm-vpn-connection.c
+++ b/src/vpn-manager/nm-vpn-connection.c
@@ -47,6 +47,8 @@
 
 #include "nm-vpn-connection-glue.h"
 
+#define NM_VPN_DEFAULT_ROUTE_METRIC 50
+
 G_DEFINE_TYPE (NMVPNConnection, nm_vpn_connection, NM_TYPE_ACTIVE_CONNECTION)
 
 typedef enum {
@@ -843,7 +845,8 @@ nm_vpn_connection_apply_config (NMVPNCon
 		nm_platform_link_set_up (priv->ip_ifindex);
 
 		if (priv->ip4_config) {
-			if (!nm_ip4_config_commit (priv->ip4_config, priv->ip_ifindex))
+			if (!nm_ip4_config_commit (priv->ip4_config, priv->ip_ifindex,
+			                           NM_VPN_DEFAULT_ROUTE_METRIC))
 				return FALSE;
 		}
 
Index: b/src/nm-ip4-config.h
===================================================================
--- a/src/nm-ip4-config.h
+++ b/src/nm-ip4-config.h
@@ -60,7 +60,7 @@ const char * nm_ip4_config_get_dbus_path
 
 /* Integration with nm-platform and nm-setting */
 NMIP4Config *nm_ip4_config_capture (int ifindex, gboolean capture_resolv_conf);
-gboolean nm_ip4_config_commit (const NMIP4Config *config, int ifindex);
+gboolean nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric);
 void nm_ip4_config_merge_setting (NMIP4Config *config, NMSettingIP4Config *setting, int default_route_metric);
 NMSetting *nm_ip4_config_create_setting (const NMIP4Config *config);
 
