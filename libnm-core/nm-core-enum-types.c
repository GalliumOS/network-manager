


/* Generated by glib-mkenums. Do not edit */

#include "config.h"

#include "nm-core-enum-types.h"

#include "nm-version-macros.h" 
#include "nm-connection.h" 
#include "nm-core-types.h" 
#include "nm-dbus-interface.h" 
#include "nm-errors.h" 
#include "nm-setting-8021x.h" 
#include "nm-setting-adsl.h" 
#include "nm-setting-bluetooth.h" 
#include "nm-setting-bond.h" 
#include "nm-setting-bridge-port.h" 
#include "nm-setting-bridge.h" 
#include "nm-setting-cdma.h" 
#include "nm-setting-connection.h" 
#include "nm-setting-dcb.h" 
#include "nm-setting-generic.h" 
#include "nm-setting-gsm.h" 
#include "nm-setting-infiniband.h" 
#include "nm-setting-ip-config.h" 
#include "nm-setting-ip-tunnel.h" 
#include "nm-setting-ip4-config.h" 
#include "nm-setting-ip6-config.h" 
#include "nm-setting-macvlan.h" 
#include "nm-setting-olpc-mesh.h" 
#include "nm-setting-ppp.h" 
#include "nm-setting-pppoe.h" 
#include "nm-setting-serial.h" 
#include "nm-setting-team-port.h" 
#include "nm-setting-team.h" 
#include "nm-setting-tun.h" 
#include "nm-setting-vlan.h" 
#include "nm-setting-vpn.h" 
#include "nm-setting-vxlan.h" 
#include "nm-setting-wimax.h" 
#include "nm-setting-wired.h" 
#include "nm-setting-wireless-security.h" 
#include "nm-setting-wireless.h" 
#include "nm-setting.h" 
#include "nm-simple-connection.h" 
#include "nm-utils.h" 
#include "nm-version.h" 
#include "nm-vpn-dbus-interface.h" 
#include "nm-vpn-editor-plugin.h" 
#include "nm-vpn-plugin-info.h"

GType
nm_connection_serialization_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_CONNECTION_SERIALIZE_ALL, "NM_CONNECTION_SERIALIZE_ALL", "all" },
        { NM_CONNECTION_SERIALIZE_NO_SECRETS, "NM_CONNECTION_SERIALIZE_NO_SECRETS", "no-secrets" },
        { NM_CONNECTION_SERIALIZE_ONLY_SECRETS, "NM_CONNECTION_SERIALIZE_ONLY_SECRETS", "only-secrets" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMConnectionSerializationFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_state_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_STATE_UNKNOWN, "NM_STATE_UNKNOWN", "unknown" },
        { NM_STATE_ASLEEP, "NM_STATE_ASLEEP", "asleep" },
        { NM_STATE_DISCONNECTED, "NM_STATE_DISCONNECTED", "disconnected" },
        { NM_STATE_DISCONNECTING, "NM_STATE_DISCONNECTING", "disconnecting" },
        { NM_STATE_CONNECTING, "NM_STATE_CONNECTING", "connecting" },
        { NM_STATE_CONNECTED_LOCAL, "NM_STATE_CONNECTED_LOCAL", "connected-local" },
        { NM_STATE_CONNECTED_SITE, "NM_STATE_CONNECTED_SITE", "connected-site" },
        { NM_STATE_CONNECTED_GLOBAL, "NM_STATE_CONNECTED_GLOBAL", "connected-global" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMState"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_connectivity_state_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_CONNECTIVITY_UNKNOWN, "NM_CONNECTIVITY_UNKNOWN", "unknown" },
        { NM_CONNECTIVITY_NONE, "NM_CONNECTIVITY_NONE", "none" },
        { NM_CONNECTIVITY_PORTAL, "NM_CONNECTIVITY_PORTAL", "portal" },
        { NM_CONNECTIVITY_LIMITED, "NM_CONNECTIVITY_LIMITED", "limited" },
        { NM_CONNECTIVITY_FULL, "NM_CONNECTIVITY_FULL", "full" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMConnectivityState"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_TYPE_UNKNOWN, "NM_DEVICE_TYPE_UNKNOWN", "unknown" },
        { NM_DEVICE_TYPE_ETHERNET, "NM_DEVICE_TYPE_ETHERNET", "ethernet" },
        { NM_DEVICE_TYPE_WIFI, "NM_DEVICE_TYPE_WIFI", "wifi" },
        { NM_DEVICE_TYPE_UNUSED1, "NM_DEVICE_TYPE_UNUSED1", "unused1" },
        { NM_DEVICE_TYPE_UNUSED2, "NM_DEVICE_TYPE_UNUSED2", "unused2" },
        { NM_DEVICE_TYPE_BT, "NM_DEVICE_TYPE_BT", "bt" },
        { NM_DEVICE_TYPE_OLPC_MESH, "NM_DEVICE_TYPE_OLPC_MESH", "olpc-mesh" },
        { NM_DEVICE_TYPE_WIMAX, "NM_DEVICE_TYPE_WIMAX", "wimax" },
        { NM_DEVICE_TYPE_MODEM, "NM_DEVICE_TYPE_MODEM", "modem" },
        { NM_DEVICE_TYPE_INFINIBAND, "NM_DEVICE_TYPE_INFINIBAND", "infiniband" },
        { NM_DEVICE_TYPE_BOND, "NM_DEVICE_TYPE_BOND", "bond" },
        { NM_DEVICE_TYPE_VLAN, "NM_DEVICE_TYPE_VLAN", "vlan" },
        { NM_DEVICE_TYPE_ADSL, "NM_DEVICE_TYPE_ADSL", "adsl" },
        { NM_DEVICE_TYPE_BRIDGE, "NM_DEVICE_TYPE_BRIDGE", "bridge" },
        { NM_DEVICE_TYPE_GENERIC, "NM_DEVICE_TYPE_GENERIC", "generic" },
        { NM_DEVICE_TYPE_TEAM, "NM_DEVICE_TYPE_TEAM", "team" },
        { NM_DEVICE_TYPE_TUN, "NM_DEVICE_TYPE_TUN", "tun" },
        { NM_DEVICE_TYPE_IP_TUNNEL, "NM_DEVICE_TYPE_IP_TUNNEL", "ip-tunnel" },
        { NM_DEVICE_TYPE_MACVLAN, "NM_DEVICE_TYPE_MACVLAN", "macvlan" },
        { NM_DEVICE_TYPE_VXLAN, "NM_DEVICE_TYPE_VXLAN", "vxlan" },
        { NM_DEVICE_TYPE_VETH, "NM_DEVICE_TYPE_VETH", "veth" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_capabilities_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_DEVICE_CAP_NONE, "NM_DEVICE_CAP_NONE", "none" },
        { NM_DEVICE_CAP_NM_SUPPORTED, "NM_DEVICE_CAP_NM_SUPPORTED", "nm-supported" },
        { NM_DEVICE_CAP_CARRIER_DETECT, "NM_DEVICE_CAP_CARRIER_DETECT", "carrier-detect" },
        { NM_DEVICE_CAP_IS_SOFTWARE, "NM_DEVICE_CAP_IS_SOFTWARE", "is-software" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMDeviceCapabilities"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_wifi_capabilities_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_WIFI_DEVICE_CAP_NONE, "NM_WIFI_DEVICE_CAP_NONE", "none" },
        { NM_WIFI_DEVICE_CAP_CIPHER_WEP40, "NM_WIFI_DEVICE_CAP_CIPHER_WEP40", "cipher-wep40" },
        { NM_WIFI_DEVICE_CAP_CIPHER_WEP104, "NM_WIFI_DEVICE_CAP_CIPHER_WEP104", "cipher-wep104" },
        { NM_WIFI_DEVICE_CAP_CIPHER_TKIP, "NM_WIFI_DEVICE_CAP_CIPHER_TKIP", "cipher-tkip" },
        { NM_WIFI_DEVICE_CAP_CIPHER_CCMP, "NM_WIFI_DEVICE_CAP_CIPHER_CCMP", "cipher-ccmp" },
        { NM_WIFI_DEVICE_CAP_WPA, "NM_WIFI_DEVICE_CAP_WPA", "wpa" },
        { NM_WIFI_DEVICE_CAP_RSN, "NM_WIFI_DEVICE_CAP_RSN", "rsn" },
        { NM_WIFI_DEVICE_CAP_AP, "NM_WIFI_DEVICE_CAP_AP", "ap" },
        { NM_WIFI_DEVICE_CAP_ADHOC, "NM_WIFI_DEVICE_CAP_ADHOC", "adhoc" },
        { NM_WIFI_DEVICE_CAP_FREQ_VALID, "NM_WIFI_DEVICE_CAP_FREQ_VALID", "freq-valid" },
        { NM_WIFI_DEVICE_CAP_FREQ_2GHZ, "NM_WIFI_DEVICE_CAP_FREQ_2GHZ", "freq-2ghz" },
        { NM_WIFI_DEVICE_CAP_FREQ_5GHZ, "NM_WIFI_DEVICE_CAP_FREQ_5GHZ", "freq-5ghz" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMDeviceWifiCapabilities"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_802_11_ap_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_802_11_AP_FLAGS_NONE, "NM_802_11_AP_FLAGS_NONE", "none" },
        { NM_802_11_AP_FLAGS_PRIVACY, "NM_802_11_AP_FLAGS_PRIVACY", "privacy" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NM80211ApFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_802_11_ap_security_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_802_11_AP_SEC_NONE, "NM_802_11_AP_SEC_NONE", "none" },
        { NM_802_11_AP_SEC_PAIR_WEP40, "NM_802_11_AP_SEC_PAIR_WEP40", "pair-wep40" },
        { NM_802_11_AP_SEC_PAIR_WEP104, "NM_802_11_AP_SEC_PAIR_WEP104", "pair-wep104" },
        { NM_802_11_AP_SEC_PAIR_TKIP, "NM_802_11_AP_SEC_PAIR_TKIP", "pair-tkip" },
        { NM_802_11_AP_SEC_PAIR_CCMP, "NM_802_11_AP_SEC_PAIR_CCMP", "pair-ccmp" },
        { NM_802_11_AP_SEC_GROUP_WEP40, "NM_802_11_AP_SEC_GROUP_WEP40", "group-wep40" },
        { NM_802_11_AP_SEC_GROUP_WEP104, "NM_802_11_AP_SEC_GROUP_WEP104", "group-wep104" },
        { NM_802_11_AP_SEC_GROUP_TKIP, "NM_802_11_AP_SEC_GROUP_TKIP", "group-tkip" },
        { NM_802_11_AP_SEC_GROUP_CCMP, "NM_802_11_AP_SEC_GROUP_CCMP", "group-ccmp" },
        { NM_802_11_AP_SEC_KEY_MGMT_PSK, "NM_802_11_AP_SEC_KEY_MGMT_PSK", "key-mgmt-psk" },
        { NM_802_11_AP_SEC_KEY_MGMT_802_1X, "NM_802_11_AP_SEC_KEY_MGMT_802_1X", "key-mgmt-802-1x" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NM80211ApSecurityFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_802_11_mode_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_802_11_MODE_UNKNOWN, "NM_802_11_MODE_UNKNOWN", "unknown" },
        { NM_802_11_MODE_ADHOC, "NM_802_11_MODE_ADHOC", "adhoc" },
        { NM_802_11_MODE_INFRA, "NM_802_11_MODE_INFRA", "infra" },
        { NM_802_11_MODE_AP, "NM_802_11_MODE_AP", "ap" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NM80211Mode"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_bluetooth_capabilities_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_BT_CAPABILITY_NONE, "NM_BT_CAPABILITY_NONE", "none" },
        { NM_BT_CAPABILITY_DUN, "NM_BT_CAPABILITY_DUN", "dun" },
        { NM_BT_CAPABILITY_NAP, "NM_BT_CAPABILITY_NAP", "nap" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMBluetoothCapabilities"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_modem_capabilities_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_DEVICE_MODEM_CAPABILITY_NONE, "NM_DEVICE_MODEM_CAPABILITY_NONE", "none" },
        { NM_DEVICE_MODEM_CAPABILITY_POTS, "NM_DEVICE_MODEM_CAPABILITY_POTS", "pots" },
        { NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO, "NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO", "cdma-evdo" },
        { NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS, "NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS", "gsm-umts" },
        { NM_DEVICE_MODEM_CAPABILITY_LTE, "NM_DEVICE_MODEM_CAPABILITY_LTE", "lte" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMDeviceModemCapabilities"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_wimax_nsp_network_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN, "NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN", "unknown" },
        { NM_WIMAX_NSP_NETWORK_TYPE_HOME, "NM_WIMAX_NSP_NETWORK_TYPE_HOME", "home" },
        { NM_WIMAX_NSP_NETWORK_TYPE_PARTNER, "NM_WIMAX_NSP_NETWORK_TYPE_PARTNER", "partner" },
        { NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER, "NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER", "roaming-partner" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMWimaxNspNetworkType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_state_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_STATE_UNKNOWN, "NM_DEVICE_STATE_UNKNOWN", "unknown" },
        { NM_DEVICE_STATE_UNMANAGED, "NM_DEVICE_STATE_UNMANAGED", "unmanaged" },
        { NM_DEVICE_STATE_UNAVAILABLE, "NM_DEVICE_STATE_UNAVAILABLE", "unavailable" },
        { NM_DEVICE_STATE_DISCONNECTED, "NM_DEVICE_STATE_DISCONNECTED", "disconnected" },
        { NM_DEVICE_STATE_PREPARE, "NM_DEVICE_STATE_PREPARE", "prepare" },
        { NM_DEVICE_STATE_CONFIG, "NM_DEVICE_STATE_CONFIG", "config" },
        { NM_DEVICE_STATE_NEED_AUTH, "NM_DEVICE_STATE_NEED_AUTH", "need-auth" },
        { NM_DEVICE_STATE_IP_CONFIG, "NM_DEVICE_STATE_IP_CONFIG", "ip-config" },
        { NM_DEVICE_STATE_IP_CHECK, "NM_DEVICE_STATE_IP_CHECK", "ip-check" },
        { NM_DEVICE_STATE_SECONDARIES, "NM_DEVICE_STATE_SECONDARIES", "secondaries" },
        { NM_DEVICE_STATE_ACTIVATED, "NM_DEVICE_STATE_ACTIVATED", "activated" },
        { NM_DEVICE_STATE_DEACTIVATING, "NM_DEVICE_STATE_DEACTIVATING", "deactivating" },
        { NM_DEVICE_STATE_FAILED, "NM_DEVICE_STATE_FAILED", "failed" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceState"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_state_reason_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_STATE_REASON_NONE, "NM_DEVICE_STATE_REASON_NONE", "none" },
        { NM_DEVICE_STATE_REASON_UNKNOWN, "NM_DEVICE_STATE_REASON_UNKNOWN", "unknown" },
        { NM_DEVICE_STATE_REASON_NOW_MANAGED, "NM_DEVICE_STATE_REASON_NOW_MANAGED", "now-managed" },
        { NM_DEVICE_STATE_REASON_NOW_UNMANAGED, "NM_DEVICE_STATE_REASON_NOW_UNMANAGED", "now-unmanaged" },
        { NM_DEVICE_STATE_REASON_CONFIG_FAILED, "NM_DEVICE_STATE_REASON_CONFIG_FAILED", "config-failed" },
        { NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE, "NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE", "ip-config-unavailable" },
        { NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED, "NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED", "ip-config-expired" },
        { NM_DEVICE_STATE_REASON_NO_SECRETS, "NM_DEVICE_STATE_REASON_NO_SECRETS", "no-secrets" },
        { NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT, "NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT", "supplicant-disconnect" },
        { NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED, "NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED", "supplicant-config-failed" },
        { NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED, "NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED", "supplicant-failed" },
        { NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT, "NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT", "supplicant-timeout" },
        { NM_DEVICE_STATE_REASON_PPP_START_FAILED, "NM_DEVICE_STATE_REASON_PPP_START_FAILED", "ppp-start-failed" },
        { NM_DEVICE_STATE_REASON_PPP_DISCONNECT, "NM_DEVICE_STATE_REASON_PPP_DISCONNECT", "ppp-disconnect" },
        { NM_DEVICE_STATE_REASON_PPP_FAILED, "NM_DEVICE_STATE_REASON_PPP_FAILED", "ppp-failed" },
        { NM_DEVICE_STATE_REASON_DHCP_START_FAILED, "NM_DEVICE_STATE_REASON_DHCP_START_FAILED", "dhcp-start-failed" },
        { NM_DEVICE_STATE_REASON_DHCP_ERROR, "NM_DEVICE_STATE_REASON_DHCP_ERROR", "dhcp-error" },
        { NM_DEVICE_STATE_REASON_DHCP_FAILED, "NM_DEVICE_STATE_REASON_DHCP_FAILED", "dhcp-failed" },
        { NM_DEVICE_STATE_REASON_SHARED_START_FAILED, "NM_DEVICE_STATE_REASON_SHARED_START_FAILED", "shared-start-failed" },
        { NM_DEVICE_STATE_REASON_SHARED_FAILED, "NM_DEVICE_STATE_REASON_SHARED_FAILED", "shared-failed" },
        { NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED, "NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED", "autoip-start-failed" },
        { NM_DEVICE_STATE_REASON_AUTOIP_ERROR, "NM_DEVICE_STATE_REASON_AUTOIP_ERROR", "autoip-error" },
        { NM_DEVICE_STATE_REASON_AUTOIP_FAILED, "NM_DEVICE_STATE_REASON_AUTOIP_FAILED", "autoip-failed" },
        { NM_DEVICE_STATE_REASON_MODEM_BUSY, "NM_DEVICE_STATE_REASON_MODEM_BUSY", "modem-busy" },
        { NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE, "NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE", "modem-no-dial-tone" },
        { NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER, "NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER", "modem-no-carrier" },
        { NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT, "NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT", "modem-dial-timeout" },
        { NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED, "NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED", "modem-dial-failed" },
        { NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED, "NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED", "modem-init-failed" },
        { NM_DEVICE_STATE_REASON_GSM_APN_FAILED, "NM_DEVICE_STATE_REASON_GSM_APN_FAILED", "gsm-apn-failed" },
        { NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING, "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING", "gsm-registration-not-searching" },
        { NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED, "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED", "gsm-registration-denied" },
        { NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT, "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT", "gsm-registration-timeout" },
        { NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED, "NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED", "gsm-registration-failed" },
        { NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED, "NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED", "gsm-pin-check-failed" },
        { NM_DEVICE_STATE_REASON_FIRMWARE_MISSING, "NM_DEVICE_STATE_REASON_FIRMWARE_MISSING", "firmware-missing" },
        { NM_DEVICE_STATE_REASON_REMOVED, "NM_DEVICE_STATE_REASON_REMOVED", "removed" },
        { NM_DEVICE_STATE_REASON_SLEEPING, "NM_DEVICE_STATE_REASON_SLEEPING", "sleeping" },
        { NM_DEVICE_STATE_REASON_CONNECTION_REMOVED, "NM_DEVICE_STATE_REASON_CONNECTION_REMOVED", "connection-removed" },
        { NM_DEVICE_STATE_REASON_USER_REQUESTED, "NM_DEVICE_STATE_REASON_USER_REQUESTED", "user-requested" },
        { NM_DEVICE_STATE_REASON_CARRIER, "NM_DEVICE_STATE_REASON_CARRIER", "carrier" },
        { NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED, "NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED", "connection-assumed" },
        { NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE, "NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE", "supplicant-available" },
        { NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND, "NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND", "modem-not-found" },
        { NM_DEVICE_STATE_REASON_BT_FAILED, "NM_DEVICE_STATE_REASON_BT_FAILED", "bt-failed" },
        { NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED, "NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED", "gsm-sim-not-inserted" },
        { NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED, "NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED", "gsm-sim-pin-required" },
        { NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED, "NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED", "gsm-sim-puk-required" },
        { NM_DEVICE_STATE_REASON_GSM_SIM_WRONG, "NM_DEVICE_STATE_REASON_GSM_SIM_WRONG", "gsm-sim-wrong" },
        { NM_DEVICE_STATE_REASON_INFINIBAND_MODE, "NM_DEVICE_STATE_REASON_INFINIBAND_MODE", "infiniband-mode" },
        { NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED, "NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED", "dependency-failed" },
        { NM_DEVICE_STATE_REASON_BR2684_FAILED, "NM_DEVICE_STATE_REASON_BR2684_FAILED", "br2684-failed" },
        { NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE, "NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE", "modem-manager-unavailable" },
        { NM_DEVICE_STATE_REASON_SSID_NOT_FOUND, "NM_DEVICE_STATE_REASON_SSID_NOT_FOUND", "ssid-not-found" },
        { NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED, "NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED", "secondary-connection-failed" },
        { NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED, "NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED", "dcb-fcoe-failed" },
        { NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED, "NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED", "teamd-control-failed" },
        { NM_DEVICE_STATE_REASON_MODEM_FAILED, "NM_DEVICE_STATE_REASON_MODEM_FAILED", "modem-failed" },
        { NM_DEVICE_STATE_REASON_MODEM_AVAILABLE, "NM_DEVICE_STATE_REASON_MODEM_AVAILABLE", "modem-available" },
        { NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT, "NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT", "sim-pin-incorrect" },
        { NM_DEVICE_STATE_REASON_NEW_ACTIVATION, "NM_DEVICE_STATE_REASON_NEW_ACTIVATION", "new-activation" },
        { NM_DEVICE_STATE_REASON_PARENT_CHANGED, "NM_DEVICE_STATE_REASON_PARENT_CHANGED", "parent-changed" },
        { NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED, "NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED", "parent-managed-changed" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceStateReason"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_metered_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_METERED_UNKNOWN, "NM_METERED_UNKNOWN", "unknown" },
        { NM_METERED_YES, "NM_METERED_YES", "yes" },
        { NM_METERED_NO, "NM_METERED_NO", "no" },
        { NM_METERED_GUESS_YES, "NM_METERED_GUESS_YES", "guess-yes" },
        { NM_METERED_GUESS_NO, "NM_METERED_GUESS_NO", "guess-no" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMMetered"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_active_connection_state_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_ACTIVE_CONNECTION_STATE_UNKNOWN, "NM_ACTIVE_CONNECTION_STATE_UNKNOWN", "unknown" },
        { NM_ACTIVE_CONNECTION_STATE_ACTIVATING, "NM_ACTIVE_CONNECTION_STATE_ACTIVATING", "activating" },
        { NM_ACTIVE_CONNECTION_STATE_ACTIVATED, "NM_ACTIVE_CONNECTION_STATE_ACTIVATED", "activated" },
        { NM_ACTIVE_CONNECTION_STATE_DEACTIVATING, "NM_ACTIVE_CONNECTION_STATE_DEACTIVATING", "deactivating" },
        { NM_ACTIVE_CONNECTION_STATE_DEACTIVATED, "NM_ACTIVE_CONNECTION_STATE_DEACTIVATED", "deactivated" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMActiveConnectionState"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_secret_agent_get_secrets_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE, "NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE", "none" },
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION, "NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION", "allow-interaction" },
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW, "NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW", "request-new" },
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED, "NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED", "user-requested" },
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM, "NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM", "only-system" },
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS, "NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS", "no-errors" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMSecretAgentGetSecretsFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_secret_agent_capabilities_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_SECRET_AGENT_CAPABILITY_NONE, "NM_SECRET_AGENT_CAPABILITY_NONE", "none" },
        { NM_SECRET_AGENT_CAPABILITY_VPN_HINTS, "NM_SECRET_AGENT_CAPABILITY_VPN_HINTS", "vpn-hints" },
        { NM_SECRET_AGENT_CAPABILITY_LAST, "NM_SECRET_AGENT_CAPABILITY_LAST", "last" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMSecretAgentCapabilities"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_ip_tunnel_mode_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_IP_TUNNEL_MODE_UNKNOWN, "NM_IP_TUNNEL_MODE_UNKNOWN", "unknown" },
        { NM_IP_TUNNEL_MODE_IPIP, "NM_IP_TUNNEL_MODE_IPIP", "ipip" },
        { NM_IP_TUNNEL_MODE_GRE, "NM_IP_TUNNEL_MODE_GRE", "gre" },
        { NM_IP_TUNNEL_MODE_SIT, "NM_IP_TUNNEL_MODE_SIT", "sit" },
        { NM_IP_TUNNEL_MODE_ISATAP, "NM_IP_TUNNEL_MODE_ISATAP", "isatap" },
        { NM_IP_TUNNEL_MODE_VTI, "NM_IP_TUNNEL_MODE_VTI", "vti" },
        { NM_IP_TUNNEL_MODE_IP6IP6, "NM_IP_TUNNEL_MODE_IP6IP6", "ip6ip6" },
        { NM_IP_TUNNEL_MODE_IPIP6, "NM_IP_TUNNEL_MODE_IPIP6", "ipip6" },
        { NM_IP_TUNNEL_MODE_IP6GRE, "NM_IP_TUNNEL_MODE_IP6GRE", "ip6gre" },
        { NM_IP_TUNNEL_MODE_VTI6, "NM_IP_TUNNEL_MODE_VTI6", "vti6" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMIPTunnelMode"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_agent_manager_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_AGENT_MANAGER_ERROR_FAILED, "NM_AGENT_MANAGER_ERROR_FAILED", "Failed" },
        { NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED, "NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED", "PermissionDenied" },
        { NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER, "NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER", "InvalidIdentifier" },
        { NM_AGENT_MANAGER_ERROR_NOT_REGISTERED, "NM_AGENT_MANAGER_ERROR_NOT_REGISTERED", "NotRegistered" },
        { NM_AGENT_MANAGER_ERROR_NO_SECRETS, "NM_AGENT_MANAGER_ERROR_NO_SECRETS", "NoSecrets" },
        { NM_AGENT_MANAGER_ERROR_USER_CANCELED, "NM_AGENT_MANAGER_ERROR_USER_CANCELED", "UserCanceled" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMAgentManagerError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_connection_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_CONNECTION_ERROR_FAILED, "NM_CONNECTION_ERROR_FAILED", "Failed" },
        { NM_CONNECTION_ERROR_SETTING_NOT_FOUND, "NM_CONNECTION_ERROR_SETTING_NOT_FOUND", "SettingNotFound" },
        { NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND, "NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND", "PropertyNotFound" },
        { NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET, "NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET", "PropertyNotSecret" },
        { NM_CONNECTION_ERROR_MISSING_SETTING, "NM_CONNECTION_ERROR_MISSING_SETTING", "MissingSetting" },
        { NM_CONNECTION_ERROR_INVALID_SETTING, "NM_CONNECTION_ERROR_INVALID_SETTING", "InvalidSetting" },
        { NM_CONNECTION_ERROR_MISSING_PROPERTY, "NM_CONNECTION_ERROR_MISSING_PROPERTY", "MissingProperty" },
        { NM_CONNECTION_ERROR_INVALID_PROPERTY, "NM_CONNECTION_ERROR_INVALID_PROPERTY", "InvalidProperty" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMConnectionError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_crypto_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_CRYPTO_ERROR_FAILED, "NM_CRYPTO_ERROR_FAILED", "failed" },
        { NM_CRYPTO_ERROR_INVALID_DATA, "NM_CRYPTO_ERROR_INVALID_DATA", "invalid-data" },
        { NM_CRYPTO_ERROR_INVALID_PASSWORD, "NM_CRYPTO_ERROR_INVALID_PASSWORD", "invalid-password" },
        { NM_CRYPTO_ERROR_UNKNOWN_CIPHER, "NM_CRYPTO_ERROR_UNKNOWN_CIPHER", "unknown-cipher" },
        { NM_CRYPTO_ERROR_DECRYPTION_FAILED, "NM_CRYPTO_ERROR_DECRYPTION_FAILED", "decryption-failed" },
        { NM_CRYPTO_ERROR_ENCRYPTION_FAILED, "NM_CRYPTO_ERROR_ENCRYPTION_FAILED", "encryption-failed" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMCryptoError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_ERROR_FAILED, "NM_DEVICE_ERROR_FAILED", "Failed" },
        { NM_DEVICE_ERROR_CREATION_FAILED, "NM_DEVICE_ERROR_CREATION_FAILED", "CreationFailed" },
        { NM_DEVICE_ERROR_INVALID_CONNECTION, "NM_DEVICE_ERROR_INVALID_CONNECTION", "InvalidConnection" },
        { NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION, "NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION", "IncompatibleConnection" },
        { NM_DEVICE_ERROR_NOT_ACTIVE, "NM_DEVICE_ERROR_NOT_ACTIVE", "NotActive" },
        { NM_DEVICE_ERROR_NOT_SOFTWARE, "NM_DEVICE_ERROR_NOT_SOFTWARE", "NotSoftware" },
        { NM_DEVICE_ERROR_NOT_ALLOWED, "NM_DEVICE_ERROR_NOT_ALLOWED", "NotAllowed" },
        { NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND, "NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND", "SpecificObjectNotFound" },
        { NM_DEVICE_ERROR_VERSION_ID_MISMATCH, "NM_DEVICE_ERROR_VERSION_ID_MISMATCH", "VersionIdMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_manager_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_MANAGER_ERROR_FAILED, "NM_MANAGER_ERROR_FAILED", "Failed" },
        { NM_MANAGER_ERROR_PERMISSION_DENIED, "NM_MANAGER_ERROR_PERMISSION_DENIED", "PermissionDenied" },
        { NM_MANAGER_ERROR_UNKNOWN_CONNECTION, "NM_MANAGER_ERROR_UNKNOWN_CONNECTION", "UnknownConnection" },
        { NM_MANAGER_ERROR_UNKNOWN_DEVICE, "NM_MANAGER_ERROR_UNKNOWN_DEVICE", "UnknownDevice" },
        { NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE, "NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE", "ConnectionNotAvailable" },
        { NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE, "NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE", "ConnectionNotActive" },
        { NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE, "NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE", "ConnectionAlreadyActive" },
        { NM_MANAGER_ERROR_DEPENDENCY_FAILED, "NM_MANAGER_ERROR_DEPENDENCY_FAILED", "DependencyFailed" },
        { NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE, "NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE", "AlreadyAsleepOrAwake" },
        { NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED, "NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED", "AlreadyEnabledOrDisabled" },
        { NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL, "NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL", "UnknownLogLevel" },
        { NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN, "NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN", "UnknownLogDomain" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMManagerError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_secret_agent_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SECRET_AGENT_ERROR_FAILED, "NM_SECRET_AGENT_ERROR_FAILED", "Failed" },
        { NM_SECRET_AGENT_ERROR_PERMISSION_DENIED, "NM_SECRET_AGENT_ERROR_PERMISSION_DENIED", "PermissionDenied" },
        { NM_SECRET_AGENT_ERROR_INVALID_CONNECTION, "NM_SECRET_AGENT_ERROR_INVALID_CONNECTION", "InvalidConnection" },
        { NM_SECRET_AGENT_ERROR_USER_CANCELED, "NM_SECRET_AGENT_ERROR_USER_CANCELED", "UserCanceled" },
        { NM_SECRET_AGENT_ERROR_AGENT_CANCELED, "NM_SECRET_AGENT_ERROR_AGENT_CANCELED", "AgentCanceled" },
        { NM_SECRET_AGENT_ERROR_NO_SECRETS, "NM_SECRET_AGENT_ERROR_NO_SECRETS", "NoSecrets" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSecretAgentError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_settings_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTINGS_ERROR_FAILED, "NM_SETTINGS_ERROR_FAILED", "Failed" },
        { NM_SETTINGS_ERROR_PERMISSION_DENIED, "NM_SETTINGS_ERROR_PERMISSION_DENIED", "PermissionDenied" },
        { NM_SETTINGS_ERROR_NOT_SUPPORTED, "NM_SETTINGS_ERROR_NOT_SUPPORTED", "NotSupported" },
        { NM_SETTINGS_ERROR_INVALID_CONNECTION, "NM_SETTINGS_ERROR_INVALID_CONNECTION", "InvalidConnection" },
        { NM_SETTINGS_ERROR_READ_ONLY_CONNECTION, "NM_SETTINGS_ERROR_READ_ONLY_CONNECTION", "ReadOnlyConnection" },
        { NM_SETTINGS_ERROR_UUID_EXISTS, "NM_SETTINGS_ERROR_UUID_EXISTS", "UuidExists" },
        { NM_SETTINGS_ERROR_INVALID_HOSTNAME, "NM_SETTINGS_ERROR_INVALID_HOSTNAME", "InvalidHostname" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingsError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_plugin_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VPN_PLUGIN_ERROR_FAILED, "NM_VPN_PLUGIN_ERROR_FAILED", "Failed" },
        { NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS, "NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS", "StartingInProgress" },
        { NM_VPN_PLUGIN_ERROR_ALREADY_STARTED, "NM_VPN_PLUGIN_ERROR_ALREADY_STARTED", "AlreadyStarted" },
        { NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS, "NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS", "StoppingInProgress" },
        { NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED, "NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED", "AlreadyStopped" },
        { NM_VPN_PLUGIN_ERROR_WRONG_STATE, "NM_VPN_PLUGIN_ERROR_WRONG_STATE", "WrongState" },
        { NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS, "NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS", "BadArguments" },
        { NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED, "NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED", "LaunchFailed" },
        { NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION, "NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION", "InvalidConnection" },
        { NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED, "NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED", "InteractiveNotSupported" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVpnPluginError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_802_1x_ck_format_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_802_1X_CK_FORMAT_UNKNOWN, "NM_SETTING_802_1X_CK_FORMAT_UNKNOWN", "unknown" },
        { NM_SETTING_802_1X_CK_FORMAT_X509, "NM_SETTING_802_1X_CK_FORMAT_X509", "x509" },
        { NM_SETTING_802_1X_CK_FORMAT_RAW_KEY, "NM_SETTING_802_1X_CK_FORMAT_RAW_KEY", "raw-key" },
        { NM_SETTING_802_1X_CK_FORMAT_PKCS12, "NM_SETTING_802_1X_CK_FORMAT_PKCS12", "pkcs12" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSetting8021xCKFormat"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_802_1x_ck_scheme_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_802_1X_CK_SCHEME_UNKNOWN, "NM_SETTING_802_1X_CK_SCHEME_UNKNOWN", "unknown" },
        { NM_SETTING_802_1X_CK_SCHEME_BLOB, "NM_SETTING_802_1X_CK_SCHEME_BLOB", "blob" },
        { NM_SETTING_802_1X_CK_SCHEME_PATH, "NM_SETTING_802_1X_CK_SCHEME_PATH", "path" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSetting8021xCKScheme"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_connection_autoconnect_slaves_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT, "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT", "default" },
        { NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO, "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO", "no" },
        { NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES, "NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES", "yes" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingConnectionAutoconnectSlaves"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_connection_lldp_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_CONNECTION_LLDP_DEFAULT, "NM_SETTING_CONNECTION_LLDP_DEFAULT", "default" },
        { NM_SETTING_CONNECTION_LLDP_DISABLE, "NM_SETTING_CONNECTION_LLDP_DISABLE", "disable" },
        { NM_SETTING_CONNECTION_LLDP_ENABLE_RX, "NM_SETTING_CONNECTION_LLDP_ENABLE_RX", "enable-rx" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingConnectionLldp"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_dcb_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_SETTING_DCB_FLAG_NONE, "NM_SETTING_DCB_FLAG_NONE", "none" },
        { NM_SETTING_DCB_FLAG_ENABLE, "NM_SETTING_DCB_FLAG_ENABLE", "enable" },
        { NM_SETTING_DCB_FLAG_ADVERTISE, "NM_SETTING_DCB_FLAG_ADVERTISE", "advertise" },
        { NM_SETTING_DCB_FLAG_WILLING, "NM_SETTING_DCB_FLAG_WILLING", "willing" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMSettingDcbFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_ip6_config_privacy_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN, "NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN", "unknown" },
        { NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED, "NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED", "disabled" },
        { NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR, "NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR", "prefer-public-addr" },
        { NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR, "NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR", "prefer-temp-addr" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingIP6ConfigPrivacy"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_ip6_config_addr_gen_mode_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64, "NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64", "eui64" },
        { NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY, "NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY", "stable-privacy" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingIP6ConfigAddrGenMode"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_macvlan_mode_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_MACVLAN_MODE_UNKNOWN, "NM_SETTING_MACVLAN_MODE_UNKNOWN", "unknown" },
        { NM_SETTING_MACVLAN_MODE_VEPA, "NM_SETTING_MACVLAN_MODE_VEPA", "vepa" },
        { NM_SETTING_MACVLAN_MODE_BRIDGE, "NM_SETTING_MACVLAN_MODE_BRIDGE", "bridge" },
        { NM_SETTING_MACVLAN_MODE_PRIVATE, "NM_SETTING_MACVLAN_MODE_PRIVATE", "private" },
        { NM_SETTING_MACVLAN_MODE_PASSTHRU, "NM_SETTING_MACVLAN_MODE_PASSTHRU", "passthru" },
        { NM_SETTING_MACVLAN_MODE_SOURCE, "NM_SETTING_MACVLAN_MODE_SOURCE", "source" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingMacvlanMode"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_serial_parity_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_SERIAL_PARITY_NONE, "NM_SETTING_SERIAL_PARITY_NONE", "none" },
        { NM_SETTING_SERIAL_PARITY_EVEN, "NM_SETTING_SERIAL_PARITY_EVEN", "even" },
        { NM_SETTING_SERIAL_PARITY_ODD, "NM_SETTING_SERIAL_PARITY_ODD", "odd" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingSerialParity"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_tun_mode_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_TUN_MODE_UNKNOWN, "NM_SETTING_TUN_MODE_UNKNOWN", "unknown" },
        { NM_SETTING_TUN_MODE_TUN, "NM_SETTING_TUN_MODE_TUN", "tun" },
        { NM_SETTING_TUN_MODE_TAP, "NM_SETTING_TUN_MODE_TAP", "tap" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingTunMode"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vlan_priority_map_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VLAN_INGRESS_MAP, "NM_VLAN_INGRESS_MAP", "ingress-map" },
        { NM_VLAN_EGRESS_MAP, "NM_VLAN_EGRESS_MAP", "egress-map" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVlanPriorityMap"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vlan_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_VLAN_FLAG_REORDER_HEADERS, "NM_VLAN_FLAG_REORDER_HEADERS", "reorder-headers" },
        { NM_VLAN_FLAG_GVRP, "NM_VLAN_FLAG_GVRP", "gvrp" },
        { NM_VLAN_FLAG_LOOSE_BINDING, "NM_VLAN_FLAG_LOOSE_BINDING", "loose-binding" },
        { NM_VLAN_FLAG_MVRP, "NM_VLAN_FLAG_MVRP", "mvrp" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMVlanFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_wired_wake_on_lan_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_SETTING_WIRED_WAKE_ON_LAN_PHY, "NM_SETTING_WIRED_WAKE_ON_LAN_PHY", "phy" },
        { NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST, "NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST", "unicast" },
        { NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST, "NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST", "multicast" },
        { NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST, "NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST", "broadcast" },
        { NM_SETTING_WIRED_WAKE_ON_LAN_ARP, "NM_SETTING_WIRED_WAKE_ON_LAN_ARP", "arp" },
        { NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC, "NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC", "magic" },
        { NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT, "NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT", "default" },
        { NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE, "NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE", "ignore" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMSettingWiredWakeOnLan"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_wep_key_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_WEP_KEY_TYPE_UNKNOWN, "NM_WEP_KEY_TYPE_UNKNOWN", "unknown" },
        { NM_WEP_KEY_TYPE_KEY, "NM_WEP_KEY_TYPE_KEY", "key" },
        { NM_WEP_KEY_TYPE_PASSPHRASE, "NM_WEP_KEY_TYPE_PASSPHRASE", "passphrase" },
        { NM_WEP_KEY_TYPE_LAST, "NM_WEP_KEY_TYPE_LAST", "last" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMWepKeyType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_wireless_powersave_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_WIRELESS_POWERSAVE_DEFAULT, "NM_SETTING_WIRELESS_POWERSAVE_DEFAULT", "default" },
        { NM_SETTING_WIRELESS_POWERSAVE_IGNORE, "NM_SETTING_WIRELESS_POWERSAVE_IGNORE", "ignore" },
        { NM_SETTING_WIRELESS_POWERSAVE_DISABLE, "NM_SETTING_WIRELESS_POWERSAVE_DISABLE", "disable" },
        { NM_SETTING_WIRELESS_POWERSAVE_ENABLE, "NM_SETTING_WIRELESS_POWERSAVE_ENABLE", "enable" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingWirelessPowersave"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_secret_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_SETTING_SECRET_FLAG_NONE, "NM_SETTING_SECRET_FLAG_NONE", "none" },
        { NM_SETTING_SECRET_FLAG_AGENT_OWNED, "NM_SETTING_SECRET_FLAG_AGENT_OWNED", "agent-owned" },
        { NM_SETTING_SECRET_FLAG_NOT_SAVED, "NM_SETTING_SECRET_FLAG_NOT_SAVED", "not-saved" },
        { NM_SETTING_SECRET_FLAG_NOT_REQUIRED, "NM_SETTING_SECRET_FLAG_NOT_REQUIRED", "not-required" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMSettingSecretFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_compare_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_COMPARE_FLAG_EXACT, "NM_SETTING_COMPARE_FLAG_EXACT", "exact" },
        { NM_SETTING_COMPARE_FLAG_FUZZY, "NM_SETTING_COMPARE_FLAG_FUZZY", "fuzzy" },
        { NM_SETTING_COMPARE_FLAG_IGNORE_ID, "NM_SETTING_COMPARE_FLAG_IGNORE_ID", "ignore-id" },
        { NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS, "NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS", "ignore-secrets" },
        { NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS, "NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS", "ignore-agent-owned-secrets" },
        { NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS, "NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS", "ignore-not-saved-secrets" },
        { NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT, "NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT", "diff-result-with-default" },
        { NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT, "NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT", "diff-result-no-default" },
        { NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP, "NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP", "ignore-timestamp" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingCompareFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_mac_randomization_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_MAC_RANDOMIZATION_DEFAULT, "NM_SETTING_MAC_RANDOMIZATION_DEFAULT", "default" },
        { NM_SETTING_MAC_RANDOMIZATION_NEVER, "NM_SETTING_MAC_RANDOMIZATION_NEVER", "never" },
        { NM_SETTING_MAC_RANDOMIZATION_ALWAYS, "NM_SETTING_MAC_RANDOMIZATION_ALWAYS", "always" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingMacRandomization"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_setting_diff_result_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SETTING_DIFF_RESULT_UNKNOWN, "NM_SETTING_DIFF_RESULT_UNKNOWN", "unknown" },
        { NM_SETTING_DIFF_RESULT_IN_A, "NM_SETTING_DIFF_RESULT_IN_A", "in-a" },
        { NM_SETTING_DIFF_RESULT_IN_B, "NM_SETTING_DIFF_RESULT_IN_B", "in-b" },
        { NM_SETTING_DIFF_RESULT_IN_A_DEFAULT, "NM_SETTING_DIFF_RESULT_IN_A_DEFAULT", "in-a-default" },
        { NM_SETTING_DIFF_RESULT_IN_B_DEFAULT, "NM_SETTING_DIFF_RESULT_IN_B_DEFAULT", "in-b-default" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSettingDiffResult"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_utils_security_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NMU_SEC_INVALID, "NMU_SEC_INVALID", "invalid" },
        { NMU_SEC_NONE, "NMU_SEC_NONE", "none" },
        { NMU_SEC_STATIC_WEP, "NMU_SEC_STATIC_WEP", "static-wep" },
        { NMU_SEC_LEAP, "NMU_SEC_LEAP", "leap" },
        { NMU_SEC_DYNAMIC_WEP, "NMU_SEC_DYNAMIC_WEP", "dynamic-wep" },
        { NMU_SEC_WPA_PSK, "NMU_SEC_WPA_PSK", "wpa-psk" },
        { NMU_SEC_WPA_ENTERPRISE, "NMU_SEC_WPA_ENTERPRISE", "wpa-enterprise" },
        { NMU_SEC_WPA2_PSK, "NMU_SEC_WPA2_PSK", "wpa2-psk" },
        { NMU_SEC_WPA2_ENTERPRISE, "NMU_SEC_WPA2_ENTERPRISE", "wpa2-enterprise" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMUtilsSecurityType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_service_state_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VPN_SERVICE_STATE_UNKNOWN, "NM_VPN_SERVICE_STATE_UNKNOWN", "unknown" },
        { NM_VPN_SERVICE_STATE_INIT, "NM_VPN_SERVICE_STATE_INIT", "init" },
        { NM_VPN_SERVICE_STATE_SHUTDOWN, "NM_VPN_SERVICE_STATE_SHUTDOWN", "shutdown" },
        { NM_VPN_SERVICE_STATE_STARTING, "NM_VPN_SERVICE_STATE_STARTING", "starting" },
        { NM_VPN_SERVICE_STATE_STARTED, "NM_VPN_SERVICE_STATE_STARTED", "started" },
        { NM_VPN_SERVICE_STATE_STOPPING, "NM_VPN_SERVICE_STATE_STOPPING", "stopping" },
        { NM_VPN_SERVICE_STATE_STOPPED, "NM_VPN_SERVICE_STATE_STOPPED", "stopped" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVpnServiceState"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_connection_state_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VPN_CONNECTION_STATE_UNKNOWN, "NM_VPN_CONNECTION_STATE_UNKNOWN", "unknown" },
        { NM_VPN_CONNECTION_STATE_PREPARE, "NM_VPN_CONNECTION_STATE_PREPARE", "prepare" },
        { NM_VPN_CONNECTION_STATE_NEED_AUTH, "NM_VPN_CONNECTION_STATE_NEED_AUTH", "need-auth" },
        { NM_VPN_CONNECTION_STATE_CONNECT, "NM_VPN_CONNECTION_STATE_CONNECT", "connect" },
        { NM_VPN_CONNECTION_STATE_IP_CONFIG_GET, "NM_VPN_CONNECTION_STATE_IP_CONFIG_GET", "ip-config-get" },
        { NM_VPN_CONNECTION_STATE_ACTIVATED, "NM_VPN_CONNECTION_STATE_ACTIVATED", "activated" },
        { NM_VPN_CONNECTION_STATE_FAILED, "NM_VPN_CONNECTION_STATE_FAILED", "failed" },
        { NM_VPN_CONNECTION_STATE_DISCONNECTED, "NM_VPN_CONNECTION_STATE_DISCONNECTED", "disconnected" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVpnConnectionState"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_connection_state_reason_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VPN_CONNECTION_STATE_REASON_UNKNOWN, "NM_VPN_CONNECTION_STATE_REASON_UNKNOWN", "unknown" },
        { NM_VPN_CONNECTION_STATE_REASON_NONE, "NM_VPN_CONNECTION_STATE_REASON_NONE", "none" },
        { NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED, "NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED", "user-disconnected" },
        { NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED, "NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED", "device-disconnected" },
        { NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED, "NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED", "service-stopped" },
        { NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID, "NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID", "ip-config-invalid" },
        { NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT, "NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT", "connect-timeout" },
        { NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT, "NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT", "service-start-timeout" },
        { NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED, "NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED", "service-start-failed" },
        { NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS, "NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS", "no-secrets" },
        { NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED, "NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED", "login-failed" },
        { NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED, "NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED", "connection-removed" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVpnConnectionStateReason"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_plugin_failure_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED, "NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED", "login-failed" },
        { NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED, "NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED", "connect-failed" },
        { NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG, "NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG", "bad-ip-config" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVpnPluginFailure"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_editor_plugin_capability_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE, "NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE", "none" },
        { NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT, "NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT", "import" },
        { NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT, "NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT", "export" },
        { NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6, "NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6", "ipv6" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMVpnEditorPluginCapability"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}



